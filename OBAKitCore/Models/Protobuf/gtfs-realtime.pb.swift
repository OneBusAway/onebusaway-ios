// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: OBAKitCore/Models/Protobuf/gtfs-realtime.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// Copyright 2015 The GTFS Specifications Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protocol definition file for GTFS Realtime.
//
// GTFS Realtime lets transit agencies provide consumers with realtime
// information about disruptions to their service (stations closed, lines not
// operating, important delays etc), location of their vehicles and expected
// arrival times.
//
// This protocol is published at:
// https://github.com/google/transit/tree/master/gtfs-realtime

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// The contents of a feed message.
/// A feed is a continuous stream of feed messages. Each message in the stream is
/// obtained as a response to an appropriate HTTP GET request.
/// A realtime feed is always defined with relation to an existing GTFS feed.
/// All the entity ids are resolved with respect to the GTFS feed.
/// Note that "required" and "optional" as stated in this file refer to Protocol
/// Buffer cardinality, not semantic cardinality.  See reference.md at
/// https://github.com/google/transit/tree/master/gtfs-realtime for field
/// semantic cardinality.
public struct TransitRealtime_FeedMessage: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Metadata about this feed and feed message.
  public var header: TransitRealtime_FeedHeader {
    get {return _header ?? TransitRealtime_FeedHeader()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  /// Contents of the feed.
  public var entity: [TransitRealtime_FeedEntity] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _header: TransitRealtime_FeedHeader? = nil
}

/// Metadata about a feed, included in feed messages.
public struct TransitRealtime_FeedHeader: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the feed specification.
  /// The current version is 2.0.  Valid versions are "2.0", "1.0".
  public var gtfsRealtimeVersion: String {
    get {return _gtfsRealtimeVersion ?? String()}
    set {_gtfsRealtimeVersion = newValue}
  }
  /// Returns true if `gtfsRealtimeVersion` has been explicitly set.
  public var hasGtfsRealtimeVersion: Bool {return self._gtfsRealtimeVersion != nil}
  /// Clears the value of `gtfsRealtimeVersion`. Subsequent reads from it will return its default value.
  public mutating func clearGtfsRealtimeVersion() {self._gtfsRealtimeVersion = nil}

  public var incrementality: TransitRealtime_FeedHeader.Incrementality {
    get {return _incrementality ?? .fullDataset}
    set {_incrementality = newValue}
  }
  /// Returns true if `incrementality` has been explicitly set.
  public var hasIncrementality: Bool {return self._incrementality != nil}
  /// Clears the value of `incrementality`. Subsequent reads from it will return its default value.
  public mutating func clearIncrementality() {self._incrementality = nil}

  /// This timestamp identifies the moment when the content of this feed has been
  /// created (in server time). In POSIX time (i.e., number of seconds since
  /// January 1st 1970 00:00:00 UTC).
  public var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  /// String that matches the feed_info.feed_version from the GTFS feed that the real
  /// time data is based on. Consumers can use this to identify which GTFS feed is
  /// currently active or when a new one is available to download.
  public var feedVersion: String {
    get {return _feedVersion ?? String()}
    set {_feedVersion = newValue}
  }
  /// Returns true if `feedVersion` has been explicitly set.
  public var hasFeedVersion: Bool {return self._feedVersion != nil}
  /// Clears the value of `feedVersion`. Subsequent reads from it will return its default value.
  public mutating func clearFeedVersion() {self._feedVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Determines whether the current fetch is incremental.  Currently,
  /// DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds
  /// that use this mode.  There are discussions on the GTFS Realtime mailing
  /// list around fully specifying the behavior of DIFFERENTIAL mode and the
  /// documentation will be updated when those discussions are finalized.
  public enum Incrementality: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case fullDataset = 0
    case differential = 1

    public init() {
      self = .fullDataset
    }

  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _gtfsRealtimeVersion: String? = nil
  fileprivate var _incrementality: TransitRealtime_FeedHeader.Incrementality? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _feedVersion: String? = nil
}

/// A definition (or update) of an entity in the transit feed.
public struct TransitRealtime_FeedEntity: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ids are used only to provide incrementality support. The id should be
  /// unique within a FeedMessage. Consequent FeedMessages may contain
  /// FeedEntities with the same id. In case of a DIFFERENTIAL update the new
  /// FeedEntity with some id will replace the old FeedEntity with the same id
  /// (or delete it - see is_deleted below).
  /// The actual GTFS entities (e.g. stations, routes, trips) referenced by the
  /// feed must be specified by explicit selectors (see EntitySelector below for
  /// more info).
  public var id: String {
    get {return _storage._id ?? String()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {_uniqueStorage()._id = nil}

  /// Whether this entity is to be deleted. Relevant only for incremental
  /// fetches.
  public var isDeleted: Bool {
    get {return _storage._isDeleted ?? false}
    set {_uniqueStorage()._isDeleted = newValue}
  }
  /// Returns true if `isDeleted` has been explicitly set.
  public var hasIsDeleted: Bool {return _storage._isDeleted != nil}
  /// Clears the value of `isDeleted`. Subsequent reads from it will return its default value.
  public mutating func clearIsDeleted() {_uniqueStorage()._isDeleted = nil}

  /// Data about the entity itself. Exactly one of the following fields must be
  /// present (unless the entity is being deleted).
  public var tripUpdate: TransitRealtime_TripUpdate {
    get {return _storage._tripUpdate ?? TransitRealtime_TripUpdate()}
    set {_uniqueStorage()._tripUpdate = newValue}
  }
  /// Returns true if `tripUpdate` has been explicitly set.
  public var hasTripUpdate: Bool {return _storage._tripUpdate != nil}
  /// Clears the value of `tripUpdate`. Subsequent reads from it will return its default value.
  public mutating func clearTripUpdate() {_uniqueStorage()._tripUpdate = nil}

  public var vehicle: TransitRealtime_VehiclePosition {
    get {return _storage._vehicle ?? TransitRealtime_VehiclePosition()}
    set {_uniqueStorage()._vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  public var hasVehicle: Bool {return _storage._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  public mutating func clearVehicle() {_uniqueStorage()._vehicle = nil}

  public var alert: TransitRealtime_Alert {
    get {return _storage._alert ?? TransitRealtime_Alert()}
    set {_uniqueStorage()._alert = newValue}
  }
  /// Returns true if `alert` has been explicitly set.
  public var hasAlert: Bool {return _storage._alert != nil}
  /// Clears the value of `alert`. Subsequent reads from it will return its default value.
  public mutating func clearAlert() {_uniqueStorage()._alert = nil}

  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var shape: TransitRealtime_Shape {
    get {return _storage._shape ?? TransitRealtime_Shape()}
    set {_uniqueStorage()._shape = newValue}
  }
  /// Returns true if `shape` has been explicitly set.
  public var hasShape: Bool {return _storage._shape != nil}
  /// Clears the value of `shape`. Subsequent reads from it will return its default value.
  public mutating func clearShape() {_uniqueStorage()._shape = nil}

  public var stop: TransitRealtime_Stop {
    get {return _storage._stop ?? TransitRealtime_Stop()}
    set {_uniqueStorage()._stop = newValue}
  }
  /// Returns true if `stop` has been explicitly set.
  public var hasStop: Bool {return _storage._stop != nil}
  /// Clears the value of `stop`. Subsequent reads from it will return its default value.
  public mutating func clearStop() {_uniqueStorage()._stop = nil}

  public var tripModifications: TransitRealtime_TripModifications {
    get {return _storage._tripModifications ?? TransitRealtime_TripModifications()}
    set {_uniqueStorage()._tripModifications = newValue}
  }
  /// Returns true if `tripModifications` has been explicitly set.
  public var hasTripModifications: Bool {return _storage._tripModifications != nil}
  /// Clears the value of `tripModifications`. Subsequent reads from it will return its default value.
  public mutating func clearTripModifications() {_uniqueStorage()._tripModifications = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Realtime update of the progress of a vehicle along a trip.
/// Depending on the value of ScheduleRelationship, a TripUpdate can specify:
/// - A trip that proceeds along the schedule.
/// - A trip that proceeds along a route but has no fixed schedule.
/// - A trip that have been added or removed with regard to schedule.
///
/// The updates can be for future, predicted arrival/departure events, or for
/// past events that already occurred.
/// Normally, updates should get more precise and more certain (see
/// uncertainty below) as the events gets closer to current time.
/// Even if that is not possible, the information for past events should be
/// precise and certain. In particular, if an update points to time in the past
/// but its update's uncertainty is not 0, the client should conclude that the
/// update is a (wrong) prediction and that the trip has not completed yet.
///
/// Note that the update can describe a trip that is already completed.
/// To this end, it is enough to provide an update for the last stop of the trip.
/// If the time of that is in the past, the client will conclude from that that
/// the whole trip is in the past (it is possible, although inconsequential, to
/// also provide updates for preceding stops).
/// This option is most relevant for a trip that has completed ahead of schedule,
/// but according to the schedule, the trip is still proceeding at the current
/// time. Removing the updates for this trip could make the client assume
/// that the trip is still proceeding.
/// Note that the feed provider is allowed, but not required, to purge past
/// updates - this is one case where this would be practically useful.
public struct TransitRealtime_TripUpdate: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Trip that this message applies to. There can be at most one
  /// TripUpdate entity for each actual trip instance.
  /// If there is none, that means there is no prediction information available.
  /// It does *not* mean that the trip is progressing according to schedule.
  public var trip: TransitRealtime_TripDescriptor {
    get {return _storage._trip ?? TransitRealtime_TripDescriptor()}
    set {_uniqueStorage()._trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  public var hasTrip: Bool {return _storage._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  public mutating func clearTrip() {_uniqueStorage()._trip = nil}

  /// Additional information on the vehicle that is serving this trip.
  public var vehicle: TransitRealtime_VehicleDescriptor {
    get {return _storage._vehicle ?? TransitRealtime_VehicleDescriptor()}
    set {_uniqueStorage()._vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  public var hasVehicle: Bool {return _storage._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  public mutating func clearVehicle() {_uniqueStorage()._vehicle = nil}

  /// Updates to StopTimes for the trip (both future, i.e., predictions, and in
  /// some cases, past ones, i.e., those that already happened).
  /// The updates must be sorted by stop_sequence, and apply for all the
  /// following stops of the trip up to the next specified one.
  ///
  /// Example 1:
  /// For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
  /// delay of 0 for stop_sequence of the current stop means that the trip is
  /// exactly on time.
  ///
  /// Example 2:
  /// For the same trip instance, 3 StopTimeUpdates are provided:
  /// - delay of 5 min for stop_sequence 3
  /// - delay of 1 min for stop_sequence 8
  /// - delay of unspecified duration for stop_sequence 10
  /// This will be interpreted as:
  /// - stop_sequences 3,4,5,6,7 have delay of 5 min.
  /// - stop_sequences 8,9 have delay of 1 min.
  /// - stop_sequences 10,... have unknown delay.
  public var stopTimeUpdate: [TransitRealtime_TripUpdate.StopTimeUpdate] {
    get {return _storage._stopTimeUpdate}
    set {_uniqueStorage()._stopTimeUpdate = newValue}
  }

  /// The most recent moment at which the vehicle's real-time progress was measured
  /// to estimate StopTimes in the future. When StopTimes in the past are provided,
  /// arrival/departure times may be earlier than this value. In POSIX
  /// time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
  public var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  /// The current schedule deviation for the trip.  Delay should only be
  /// specified when the prediction is given relative to some existing schedule
  /// in GTFS.
  ///
  /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
  /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
  /// means that the vehicle is exactly on time.
  ///
  /// Delay information in StopTimeUpdates take precedent of trip-level delay
  /// information, such that trip-level delay is only propagated until the next
  /// stop along the trip with a StopTimeUpdate delay value specified.
  ///
  /// Feed providers are strongly encouraged to provide a TripUpdate.timestamp
  /// value indicating when the delay value was last updated, in order to
  /// evaluate the freshness of the data.
  ///
  /// NOTE: This field is still experimental, and subject to change. It may be
  /// formally adopted in the future.
  public var delay: Int32 {
    get {return _storage._delay ?? 0}
    set {_uniqueStorage()._delay = newValue}
  }
  /// Returns true if `delay` has been explicitly set.
  public var hasDelay: Bool {return _storage._delay != nil}
  /// Clears the value of `delay`. Subsequent reads from it will return its default value.
  public mutating func clearDelay() {_uniqueStorage()._delay = nil}

  public var tripProperties: TransitRealtime_TripUpdate.TripProperties {
    get {return _storage._tripProperties ?? TransitRealtime_TripUpdate.TripProperties()}
    set {_uniqueStorage()._tripProperties = newValue}
  }
  /// Returns true if `tripProperties` has been explicitly set.
  public var hasTripProperties: Bool {return _storage._tripProperties != nil}
  /// Clears the value of `tripProperties`. Subsequent reads from it will return its default value.
  public mutating func clearTripProperties() {_uniqueStorage()._tripProperties = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Timing information for a single predicted event (either arrival or
  /// departure).
  /// Timing consists of delay and/or estimated time, and uncertainty.
  /// - delay should be used when the prediction is given relative to some
  ///   existing schedule in GTFS.
  /// - time should be given whether there is a predicted schedule or not. If
  ///   both time and delay are specified, time will take precedence
  ///   (although normally, time, if given for a scheduled trip, should be
  ///   equal to scheduled time in GTFS + delay).
  ///
  /// Uncertainty applies equally to both time and delay.
  /// The uncertainty roughly specifies the expected error in true delay (but
  /// note, we don't yet define its precise statistical meaning). It's possible
  /// for the uncertainty to be 0, for example for trains that are driven under
  /// computer timing control.
  public struct StopTimeEvent: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Delay (in seconds) can be positive (meaning that the vehicle is late) or
    /// negative (meaning that the vehicle is ahead of schedule). Delay of 0
    /// means that the vehicle is exactly on time.
    public var delay: Int32 {
      get {return _delay ?? 0}
      set {_delay = newValue}
    }
    /// Returns true if `delay` has been explicitly set.
    public var hasDelay: Bool {return self._delay != nil}
    /// Clears the value of `delay`. Subsequent reads from it will return its default value.
    public mutating func clearDelay() {self._delay = nil}

    /// Event as absolute time.
    /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
    /// UTC).
    public var time: Int64 {
      get {return _time ?? 0}
      set {_time = newValue}
    }
    /// Returns true if `time` has been explicitly set.
    public var hasTime: Bool {return self._time != nil}
    /// Clears the value of `time`. Subsequent reads from it will return its default value.
    public mutating func clearTime() {self._time = nil}

    /// If uncertainty is omitted, it is interpreted as unknown.
    /// If the prediction is unknown or too uncertain, the delay (or time) field
    /// should be empty. In such case, the uncertainty field is ignored.
    /// To specify a completely certain prediction, set its uncertainty to 0.
    public var uncertainty: Int32 {
      get {return _uncertainty ?? 0}
      set {_uncertainty = newValue}
    }
    /// Returns true if `uncertainty` has been explicitly set.
    public var hasUncertainty: Bool {return self._uncertainty != nil}
    /// Clears the value of `uncertainty`. Subsequent reads from it will return its default value.
    public mutating func clearUncertainty() {self._uncertainty = nil}

    /// Scheduled time for a NEW, REPLACEMENT, or DUPLICATED trip.
    /// In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
    /// UTC).
    /// Optional if TripUpdate.schedule_relationship is NEW, REPLACEMENT or DUPLICATED, forbidden otherwise.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var scheduledTime: Int64 {
      get {return _scheduledTime ?? 0}
      set {_scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {return self._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {self._scheduledTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _delay: Int32? = nil
    fileprivate var _time: Int64? = nil
    fileprivate var _uncertainty: Int32? = nil
    fileprivate var _scheduledTime: Int64? = nil
  }

  /// Realtime update for arrival and/or departure events for a given stop on a
  /// trip. Updates can be supplied for both past and future events.
  /// The producer is allowed, although not required, to drop past events.
  public struct StopTimeUpdate: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
    public var stopSequence: UInt32 {
      get {return _stopSequence ?? 0}
      set {_stopSequence = newValue}
    }
    /// Returns true if `stopSequence` has been explicitly set.
    public var hasStopSequence: Bool {return self._stopSequence != nil}
    /// Clears the value of `stopSequence`. Subsequent reads from it will return its default value.
    public mutating func clearStopSequence() {self._stopSequence = nil}

    /// Must be the same as in stops.txt in the corresponding GTFS feed.
    public var stopID: String {
      get {return _stopID ?? String()}
      set {_stopID = newValue}
    }
    /// Returns true if `stopID` has been explicitly set.
    public var hasStopID: Bool {return self._stopID != nil}
    /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
    public mutating func clearStopID() {self._stopID = nil}

    public var arrival: TransitRealtime_TripUpdate.StopTimeEvent {
      get {return _arrival ?? TransitRealtime_TripUpdate.StopTimeEvent()}
      set {_arrival = newValue}
    }
    /// Returns true if `arrival` has been explicitly set.
    public var hasArrival: Bool {return self._arrival != nil}
    /// Clears the value of `arrival`. Subsequent reads from it will return its default value.
    public mutating func clearArrival() {self._arrival = nil}

    public var departure: TransitRealtime_TripUpdate.StopTimeEvent {
      get {return _departure ?? TransitRealtime_TripUpdate.StopTimeEvent()}
      set {_departure = newValue}
    }
    /// Returns true if `departure` has been explicitly set.
    public var hasDeparture: Bool {return self._departure != nil}
    /// Clears the value of `departure`. Subsequent reads from it will return its default value.
    public mutating func clearDeparture() {self._departure = nil}

    /// Expected occupancy after departure from the given stop.
    /// Should be provided only for future stops.
    /// In order to provide departure_occupancy_status without either arrival or
    /// departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. 
    public var departureOccupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus {
      get {return _departureOccupancyStatus ?? .empty}
      set {_departureOccupancyStatus = newValue}
    }
    /// Returns true if `departureOccupancyStatus` has been explicitly set.
    public var hasDepartureOccupancyStatus: Bool {return self._departureOccupancyStatus != nil}
    /// Clears the value of `departureOccupancyStatus`. Subsequent reads from it will return its default value.
    public mutating func clearDepartureOccupancyStatus() {self._departureOccupancyStatus = nil}

    public var scheduleRelationship: TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship {
      get {return _scheduleRelationship ?? .scheduled}
      set {_scheduleRelationship = newValue}
    }
    /// Returns true if `scheduleRelationship` has been explicitly set.
    public var hasScheduleRelationship: Bool {return self._scheduleRelationship != nil}
    /// Clears the value of `scheduleRelationship`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleRelationship() {self._scheduleRelationship = nil}

    /// Realtime updates for certain properties defined within GTFS stop_times.txt
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var stopTimeProperties: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties {
      get {return _stopTimeProperties ?? TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties()}
      set {_stopTimeProperties = newValue}
    }
    /// Returns true if `stopTimeProperties` has been explicitly set.
    public var hasStopTimeProperties: Bool {return self._stopTimeProperties != nil}
    /// Clears the value of `stopTimeProperties`. Subsequent reads from it will return its default value.
    public mutating func clearStopTimeProperties() {self._stopTimeProperties = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The relation between the StopTimeEvents and the static schedule.
    public enum ScheduleRelationship: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

      /// The vehicle is proceeding in accordance with its static schedule of
      /// stops, although not necessarily according to the times of the schedule.
      /// At least one of arrival and departure must be provided. If the schedule
      /// for this stop contains both arrival and departure times then so must
      /// this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0)
      /// should not have a SCHEDULED value and should use UNSCHEDULED instead.
      case scheduled = 0

      /// The stop is skipped, i.e., the vehicle will not stop at this stop.
      /// Arrival and departure are optional.
      case skipped = 1

      /// No StopTimeEvents are given for this stop.
      /// The main intention for this value is to give time predictions only for
      /// part of a trip, i.e., if the last update for a trip has a NO_DATA
      /// specifier, then StopTimeEvents for the rest of the stops in the trip
      /// are considered to be unspecified as well.
      /// Neither arrival nor departure should be supplied.
      case noData = 2

      /// The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0.
      /// This value should not be used for trips that are not defined in GTFS frequencies.txt,
      /// or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates
      /// with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED.
      /// NOTE: This field is still experimental, and subject to change. It may be
      /// formally adopted in the future.
      case unscheduled = 3

      public init() {
        self = .scheduled
      }

    }

    /// Provides the updated values for the stop time.
    /// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
    public struct StopTimeProperties: SwiftProtobuf.ExtensibleMessage, Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt.
      /// The new assigned_stop_id should not result in a significantly different trip experience for the end user than
      /// the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an
      /// "unusual change" if the new stop was presented within an app without any additional context.
      /// For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the
      /// same station as the stop originally defined in GTFS stop_times.txt.
      /// To assign a stop without providing any real-time arrival or departure predictions, populate this field and set
      /// StopTimeUpdate.schedule_relationship = NO_DATA.
      /// If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If
      /// `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`.
      /// Platform assignments should be reflected in other GTFS-realtime fields as well
      /// (e.g., `VehiclePosition.stop_id`).
      /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
      public var assignedStopID: String {
        get {return _assignedStopID ?? String()}
        set {_assignedStopID = newValue}
      }
      /// Returns true if `assignedStopID` has been explicitly set.
      public var hasAssignedStopID: Bool {return self._assignedStopID != nil}
      /// Clears the value of `assignedStopID`. Subsequent reads from it will return its default value.
      public mutating func clearAssignedStopID() {self._assignedStopID = nil}

      /// The updated headsign of the vehicle at the stop.
      /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
      public var stopHeadsign: String {
        get {return _stopHeadsign ?? String()}
        set {_stopHeadsign = newValue}
      }
      /// Returns true if `stopHeadsign` has been explicitly set.
      public var hasStopHeadsign: Bool {return self._stopHeadsign != nil}
      /// Clears the value of `stopHeadsign`. Subsequent reads from it will return its default value.
      public mutating func clearStopHeadsign() {self._stopHeadsign = nil}

      /// The updated pickup of the vehicle at the stop.
      /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
      public var pickupType: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType {
        get {return _pickupType ?? .regular}
        set {_pickupType = newValue}
      }
      /// Returns true if `pickupType` has been explicitly set.
      public var hasPickupType: Bool {return self._pickupType != nil}
      /// Clears the value of `pickupType`. Subsequent reads from it will return its default value.
      public mutating func clearPickupType() {self._pickupType = nil}

      /// The updated drop off of the vehicle at the stop.
      /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
      public var dropOffType: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType {
        get {return _dropOffType ?? .regular}
        set {_dropOffType = newValue}
      }
      /// Returns true if `dropOffType` has been explicitly set.
      public var hasDropOffType: Bool {return self._dropOffType != nil}
      /// Clears the value of `dropOffType`. Subsequent reads from it will return its default value.
      public mutating func clearDropOffType() {self._dropOffType = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum DropOffPickupType: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

        /// Regularly scheduled pickup/dropoff.
        case regular = 0

        /// No pickup/dropoff available
        case none = 1

        /// Must phone agency to arrange pickup/dropoff.
        case phoneAgency = 2

        /// Must coordinate with driver to arrange pickup/dropoff.
        case coordinateWithDriver = 3

        public init() {
          self = .regular
        }

      }

      public init() {}

      public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
      fileprivate var _assignedStopID: String? = nil
      fileprivate var _stopHeadsign: String? = nil
      fileprivate var _pickupType: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType? = nil
      fileprivate var _dropOffType: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType? = nil
    }

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _stopSequence: UInt32? = nil
    fileprivate var _stopID: String? = nil
    fileprivate var _arrival: TransitRealtime_TripUpdate.StopTimeEvent? = nil
    fileprivate var _departure: TransitRealtime_TripUpdate.StopTimeEvent? = nil
    fileprivate var _departureOccupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus? = nil
    fileprivate var _scheduleRelationship: TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship? = nil
    fileprivate var _stopTimeProperties: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties? = nil
  }

  /// Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the
  /// trip_id, start_date, and start_time of a DUPLICATED trip. 
  /// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
  public struct TripProperties: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt
    /// but will start at a different service date and/or time (defined using the TripProperties.start_date and
    /// TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different
    /// than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not
    /// be populated and will be ignored by consumers.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var tripID: String {
      get {return _tripID ?? String()}
      set {_tripID = newValue}
    }
    /// Returns true if `tripID` has been explicitly set.
    public var hasTripID: Bool {return self._tripID != nil}
    /// Clears the value of `tripID`. Subsequent reads from it will return its default value.
    public mutating func clearTripID() {self._tripID = nil}

    /// Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if
    /// schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var startDate: String {
      get {return _startDate ?? String()}
      set {_startDate = newValue}
    }
    /// Returns true if `startDate` has been explicitly set.
    public var hasStartDate: Bool {return self._startDate != nil}
    /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
    public mutating func clearStartDate() {self._startDate = nil}

    /// Defines the departure start time of the trip when it’s duplicated. See definition of stop_times.departure_time
    /// in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset
    /// between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a
    /// departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value
    /// of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction
    /// delay values are applied to this calculated schedule time to determine the predicted time. For example, if a
    /// departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time
    /// prediction time values do not have any offset applied to them and indicate the predicted time as provided.
    /// For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time
    /// is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be
    /// populated and will be ignored by consumers.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var startTime: String {
      get {return _startTime ?? String()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {return self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// Specifies the identifier of the shape of the vehicle travel path when the trip shape differs from the shape specified in (CSV) GTFS
    /// or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS.
    /// If a shape is neither defined in (CSV) GTFS nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt or a `Shape` in the same (protobuf) real-time feed. 
    /// The order of stops (stop sequences) for this trip must remain the same as (CSV) GTFS. 
    /// If it refers to a `Shape` entity in the same real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
    /// Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should be marked as schedule_relationship=SKIPPED or more details can be provided via a `TripModifications` message.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. 
    public var shapeID: String {
      get {return _shapeID ?? String()}
      set {_shapeID = newValue}
    }
    /// Returns true if `shapeID` has been explicitly set.
    public var hasShapeID: Bool {return self._shapeID != nil}
    /// Clears the value of `shapeID`. Subsequent reads from it will return its default value.
    public mutating func clearShapeID() {self._shapeID = nil}

    /// Specifies the headsign for this trip when it differs from the original.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var tripHeadsign: String {
      get {return _tripHeadsign ?? String()}
      set {_tripHeadsign = newValue}
    }
    /// Returns true if `tripHeadsign` has been explicitly set.
    public var hasTripHeadsign: Bool {return self._tripHeadsign != nil}
    /// Clears the value of `tripHeadsign`. Subsequent reads from it will return its default value.
    public mutating func clearTripHeadsign() {self._tripHeadsign = nil}

    /// Specifies the name for this trip when it differs from the original.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    public var tripShortName: String {
      get {return _tripShortName ?? String()}
      set {_tripShortName = newValue}
    }
    /// Returns true if `tripShortName` has been explicitly set.
    public var hasTripShortName: Bool {return self._tripShortName != nil}
    /// Clears the value of `tripShortName`. Subsequent reads from it will return its default value.
    public mutating func clearTripShortName() {self._tripShortName = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _tripID: String? = nil
    fileprivate var _startDate: String? = nil
    fileprivate var _startTime: String? = nil
    fileprivate var _shapeID: String? = nil
    fileprivate var _tripHeadsign: String? = nil
    fileprivate var _tripShortName: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Realtime positioning information for a given vehicle.
public struct TransitRealtime_VehiclePosition: SwiftProtobuf.ExtensibleMessage, @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Trip that this vehicle is serving.
  /// Can be empty or partial if the vehicle can not be identified with a given
  /// trip instance.
  public var trip: TransitRealtime_TripDescriptor {
    get {return _storage._trip ?? TransitRealtime_TripDescriptor()}
    set {_uniqueStorage()._trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  public var hasTrip: Bool {return _storage._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  public mutating func clearTrip() {_uniqueStorage()._trip = nil}

  /// Additional information on the vehicle that is serving this trip.
  public var vehicle: TransitRealtime_VehicleDescriptor {
    get {return _storage._vehicle ?? TransitRealtime_VehicleDescriptor()}
    set {_uniqueStorage()._vehicle = newValue}
  }
  /// Returns true if `vehicle` has been explicitly set.
  public var hasVehicle: Bool {return _storage._vehicle != nil}
  /// Clears the value of `vehicle`. Subsequent reads from it will return its default value.
  public mutating func clearVehicle() {_uniqueStorage()._vehicle = nil}

  /// Current position of this vehicle.
  public var position: TransitRealtime_Position {
    get {return _storage._position ?? TransitRealtime_Position()}
    set {_uniqueStorage()._position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  public var hasPosition: Bool {return _storage._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  public mutating func clearPosition() {_uniqueStorage()._position = nil}

  /// The stop sequence index of the current stop. The meaning of
  /// current_stop_sequence (i.e., the stop that it refers to) is determined by
  /// current_status.
  /// If current_status is missing IN_TRANSIT_TO is assumed.
  public var currentStopSequence: UInt32 {
    get {return _storage._currentStopSequence ?? 0}
    set {_uniqueStorage()._currentStopSequence = newValue}
  }
  /// Returns true if `currentStopSequence` has been explicitly set.
  public var hasCurrentStopSequence: Bool {return _storage._currentStopSequence != nil}
  /// Clears the value of `currentStopSequence`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentStopSequence() {_uniqueStorage()._currentStopSequence = nil}

  /// Identifies the current stop. The value must be the same as in stops.txt in
  /// the corresponding GTFS feed.
  public var stopID: String {
    get {return _storage._stopID ?? String()}
    set {_uniqueStorage()._stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  public var hasStopID: Bool {return _storage._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  public mutating func clearStopID() {_uniqueStorage()._stopID = nil}

  /// The exact status of the vehicle with respect to the current stop.
  /// Ignored if current_stop_sequence is missing.
  public var currentStatus: TransitRealtime_VehiclePosition.VehicleStopStatus {
    get {return _storage._currentStatus ?? .inTransitTo}
    set {_uniqueStorage()._currentStatus = newValue}
  }
  /// Returns true if `currentStatus` has been explicitly set.
  public var hasCurrentStatus: Bool {return _storage._currentStatus != nil}
  /// Clears the value of `currentStatus`. Subsequent reads from it will return its default value.
  public mutating func clearCurrentStatus() {_uniqueStorage()._currentStatus = nil}

  /// Moment at which the vehicle's position was measured. In POSIX time
  /// (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
  public var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  public var congestionLevel: TransitRealtime_VehiclePosition.CongestionLevel {
    get {return _storage._congestionLevel ?? .unknownCongestionLevel}
    set {_uniqueStorage()._congestionLevel = newValue}
  }
  /// Returns true if `congestionLevel` has been explicitly set.
  public var hasCongestionLevel: Bool {return _storage._congestionLevel != nil}
  /// Clears the value of `congestionLevel`. Subsequent reads from it will return its default value.
  public mutating func clearCongestionLevel() {_uniqueStorage()._congestionLevel = nil}

  /// If multi_carriage_status is populated with per-carriage OccupancyStatus,
  /// then this field should describe the entire vehicle with all carriages accepting passengers considered.
  public var occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus {
    get {return _storage._occupancyStatus ?? .empty}
    set {_uniqueStorage()._occupancyStatus = newValue}
  }
  /// Returns true if `occupancyStatus` has been explicitly set.
  public var hasOccupancyStatus: Bool {return _storage._occupancyStatus != nil}
  /// Clears the value of `occupancyStatus`. Subsequent reads from it will return its default value.
  public mutating func clearOccupancyStatus() {_uniqueStorage()._occupancyStatus = nil}

  /// A percentage value indicating the degree of passenger occupancy in the vehicle.
  /// The values are represented as an integer without decimals. 0 means 0% and 100 means 100%.
  /// The value 100 should represent the total maximum occupancy the vehicle was designed for,
  /// including both seated and standing capacity, and current operating regulations allow.
  /// The value may exceed 100 if there are more passengers than the maximum designed capacity.
  /// The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle.
  /// If multi_carriage_status is populated with per-carriage occupancy_percentage, 
  /// then this field should describe the entire vehicle with all carriages accepting passengers considered.
  /// This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var occupancyPercentage: UInt32 {
    get {return _storage._occupancyPercentage ?? 0}
    set {_uniqueStorage()._occupancyPercentage = newValue}
  }
  /// Returns true if `occupancyPercentage` has been explicitly set.
  public var hasOccupancyPercentage: Bool {return _storage._occupancyPercentage != nil}
  /// Clears the value of `occupancyPercentage`. Subsequent reads from it will return its default value.
  public mutating func clearOccupancyPercentage() {_uniqueStorage()._occupancyPercentage = nil}

  /// Details of the multiple carriages of this given vehicle.
  /// The first occurrence represents the first carriage of the vehicle, 
  /// given the current direction of travel. 
  /// The number of occurrences of the multi_carriage_details 
  /// field represents the number of carriages of the vehicle.
  /// It also includes non boardable carriages, 
  /// like engines, maintenance carriages, etc… as they provide valuable 
  /// information to passengers about where to stand on a platform.
  /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
  public var multiCarriageDetails: [TransitRealtime_VehiclePosition.CarriageDetails] {
    get {return _storage._multiCarriageDetails}
    set {_uniqueStorage()._multiCarriageDetails = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum VehicleStopStatus: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// The vehicle is just about to arrive at the stop (on a stop
    /// display, the vehicle symbol typically flashes).
    case incomingAt = 0

    /// The vehicle is standing at the stop.
    case stoppedAt = 1

    /// The vehicle has departed and is in transit to the next stop.
    case inTransitTo = 2

    public init() {
      self = .incomingAt
    }

  }

  /// Congestion level that is affecting this vehicle.
  public enum CongestionLevel: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknownCongestionLevel = 0
    case runningSmoothly = 1
    case stopAndGo = 2
    case congestion = 3

    /// People leaving their cars.
    case severeCongestion = 4

    public init() {
      self = .unknownCongestionLevel
    }

  }

  /// The state of passenger occupancy for the vehicle or carriage.
  /// Individual producers may not publish all OccupancyStatus values. Therefore, consumers
  /// must not assume that the OccupancyStatus values follow a linear scale.
  /// Consumers should represent OccupancyStatus values as the state indicated 
  /// and intended by the producer. Likewise, producers must use OccupancyStatus values that
  /// correspond to actual vehicle occupancy states.
  /// For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`.
  /// This field is still experimental, and subject to change. It may be formally adopted in the future.
  public enum OccupancyStatus: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// The vehicle or carriage is considered empty by most measures, and has few or no
    /// passengers onboard, but is still accepting passengers.
    case empty = 0

    /// The vehicle or carriage has a large number of seats available.
    /// The amount of free seats out of the total seats available to be
    /// considered large enough to fall into this category is determined at the
    /// discretion of the producer.
    case manySeatsAvailable = 1

    /// The vehicle or carriage has a relatively small number of seats available.
    /// The amount of free seats out of the total seats available to be
    /// considered small enough to fall into this category is determined at the
    /// discretion of the feed producer.
    case fewSeatsAvailable = 2

    /// The vehicle or carriage can currently accommodate only standing passengers.
    case standingRoomOnly = 3

    /// The vehicle or carriage can currently accommodate only standing passengers
    /// and has limited space for them.
    case crushedStandingRoomOnly = 4

    /// The vehicle or carriage is considered full by most measures, but may still be
    /// allowing passengers to board.
    case full = 5

    /// The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding.
    case notAcceptingPassengers = 6

    /// The vehicle or carriage doesn't have any occupancy data available at that time.
    case noDataAvailable = 7

    /// The vehicle or carriage is not boardable and never accepts passengers.
    /// Useful for special vehicles or carriages (engine, maintenance carriage, etc…).
    case notBoardable = 8

    public init() {
      self = .empty
    }

  }

  /// Carriage specific details, used for vehicles composed of several carriages
  /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
  public struct CarriageDetails: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Identification of the carriage. Should be unique per vehicle.
    public var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    public var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    public mutating func clearID() {self._id = nil}

    /// User visible label that may be shown to the passenger to help identify
    /// the carriage. Example: "7712", "Car ABC-32", etc...
    /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    public var label: String {
      get {return _label ?? String()}
      set {_label = newValue}
    }
    /// Returns true if `label` has been explicitly set.
    public var hasLabel: Bool {return self._label != nil}
    /// Clears the value of `label`. Subsequent reads from it will return its default value.
    public mutating func clearLabel() {self._label = nil}

    /// Occupancy status for this given carriage, in this vehicle
    /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    public var occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus {
      get {return _occupancyStatus ?? .noDataAvailable}
      set {_occupancyStatus = newValue}
    }
    /// Returns true if `occupancyStatus` has been explicitly set.
    public var hasOccupancyStatus: Bool {return self._occupancyStatus != nil}
    /// Clears the value of `occupancyStatus`. Subsequent reads from it will return its default value.
    public mutating func clearOccupancyStatus() {self._occupancyStatus = nil}

    /// Occupancy percentage for this given carriage, in this vehicle.
    /// Follows the same rules as "VehiclePosition.occupancy_percentage"
    /// -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise)
    /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    public var occupancyPercentage: Int32 {
      get {return _occupancyPercentage ?? -1}
      set {_occupancyPercentage = newValue}
    }
    /// Returns true if `occupancyPercentage` has been explicitly set.
    public var hasOccupancyPercentage: Bool {return self._occupancyPercentage != nil}
    /// Clears the value of `occupancyPercentage`. Subsequent reads from it will return its default value.
    public mutating func clearOccupancyPercentage() {self._occupancyPercentage = nil}

    /// Identifies the order of this carriage with respect to the other
    /// carriages in the vehicle's list of CarriageDetails.
    /// The first carriage in the direction of travel must have a value of 1.
    /// The second value corresponds to the second carriage in the direction
    /// of travel and must have a value of 2, and so forth.
    /// For example, the first carriage in the direction of travel has a value of 1.
    /// If the second carriage in the direction of travel has a value of 3,
    /// consumers will discard data for all carriages (i.e., the multi_carriage_details field).
    /// Carriages without data must be represented with a valid carriage_sequence number and the fields 
    /// without data should be omitted (alternately, those fields could also be included and set to the "no data" values).
    /// This message/field is still experimental, and subject to change. It may be formally adopted in the future.
    public var carriageSequence: UInt32 {
      get {return _carriageSequence ?? 0}
      set {_carriageSequence = newValue}
    }
    /// Returns true if `carriageSequence` has been explicitly set.
    public var hasCarriageSequence: Bool {return self._carriageSequence != nil}
    /// Clears the value of `carriageSequence`. Subsequent reads from it will return its default value.
    public mutating func clearCarriageSequence() {self._carriageSequence = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _id: String? = nil
    fileprivate var _label: String? = nil
    fileprivate var _occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus? = nil
    fileprivate var _occupancyPercentage: Int32? = nil
    fileprivate var _carriageSequence: UInt32? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _storage = _StorageClass.defaultInstance
}

/// An alert, indicating some sort of incident in the public transit network.
public struct TransitRealtime_Alert: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time when the alert should be shown to the user. If missing, the
  /// alert will be shown as long as it appears in the feed.
  /// If multiple ranges are given, the alert will be shown during all of them.
  public var activePeriod: [TransitRealtime_TimeRange] = []

  /// Entities whose users we should notify of this alert.
  public var informedEntity: [TransitRealtime_EntitySelector] = []

  public var cause: TransitRealtime_Alert.Cause {
    get {return _cause ?? .unknownCause}
    set {_cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  public var hasCause: Bool {return self._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  public mutating func clearCause() {self._cause = nil}

  public var effect: TransitRealtime_Alert.Effect {
    get {return _effect ?? .unknownEffect}
    set {_effect = newValue}
  }
  /// Returns true if `effect` has been explicitly set.
  public var hasEffect: Bool {return self._effect != nil}
  /// Clears the value of `effect`. Subsequent reads from it will return its default value.
  public mutating func clearEffect() {self._effect = nil}

  /// The URL which provides additional information about the alert.
  public var url: TransitRealtime_TranslatedString {
    get {return _url ?? TransitRealtime_TranslatedString()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  public var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  public mutating func clearURL() {self._url = nil}

  /// Alert header. Contains a short summary of the alert text as plain-text.
  public var headerText: TransitRealtime_TranslatedString {
    get {return _headerText ?? TransitRealtime_TranslatedString()}
    set {_headerText = newValue}
  }
  /// Returns true if `headerText` has been explicitly set.
  public var hasHeaderText: Bool {return self._headerText != nil}
  /// Clears the value of `headerText`. Subsequent reads from it will return its default value.
  public mutating func clearHeaderText() {self._headerText = nil}

  /// Full description for the alert as plain-text. The information in the
  /// description should add to the information of the header.
  public var descriptionText: TransitRealtime_TranslatedString {
    get {return _descriptionText ?? TransitRealtime_TranslatedString()}
    set {_descriptionText = newValue}
  }
  /// Returns true if `descriptionText` has been explicitly set.
  public var hasDescriptionText: Bool {return self._descriptionText != nil}
  /// Clears the value of `descriptionText`. Subsequent reads from it will return its default value.
  public mutating func clearDescriptionText() {self._descriptionText = nil}

  /// Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text.
  public var ttsHeaderText: TransitRealtime_TranslatedString {
    get {return _ttsHeaderText ?? TransitRealtime_TranslatedString()}
    set {_ttsHeaderText = newValue}
  }
  /// Returns true if `ttsHeaderText` has been explicitly set.
  public var hasTtsHeaderText: Bool {return self._ttsHeaderText != nil}
  /// Clears the value of `ttsHeaderText`. Subsequent reads from it will return its default value.
  public mutating func clearTtsHeaderText() {self._ttsHeaderText = nil}

  /// Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text.
  public var ttsDescriptionText: TransitRealtime_TranslatedString {
    get {return _ttsDescriptionText ?? TransitRealtime_TranslatedString()}
    set {_ttsDescriptionText = newValue}
  }
  /// Returns true if `ttsDescriptionText` has been explicitly set.
  public var hasTtsDescriptionText: Bool {return self._ttsDescriptionText != nil}
  /// Clears the value of `ttsDescriptionText`. Subsequent reads from it will return its default value.
  public mutating func clearTtsDescriptionText() {self._ttsDescriptionText = nil}

  public var severityLevel: TransitRealtime_Alert.SeverityLevel {
    get {return _severityLevel ?? .unknownSeverity}
    set {_severityLevel = newValue}
  }
  /// Returns true if `severityLevel` has been explicitly set.
  public var hasSeverityLevel: Bool {return self._severityLevel != nil}
  /// Clears the value of `severityLevel`. Subsequent reads from it will return its default value.
  public mutating func clearSeverityLevel() {self._severityLevel = nil}

  /// TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text.
  /// The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. 
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var image: TransitRealtime_TranslatedImage {
    get {return _image ?? TransitRealtime_TranslatedImage()}
    set {_image = newValue}
  }
  /// Returns true if `image` has been explicitly set.
  public var hasImage: Bool {return self._image != nil}
  /// Clears the value of `image`. Subsequent reads from it will return its default value.
  public mutating func clearImage() {self._image = nil}

  /// Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed
  /// or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt.
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var imageAlternativeText: TransitRealtime_TranslatedString {
    get {return _imageAlternativeText ?? TransitRealtime_TranslatedString()}
    set {_imageAlternativeText = newValue}
  }
  /// Returns true if `imageAlternativeText` has been explicitly set.
  public var hasImageAlternativeText: Bool {return self._imageAlternativeText != nil}
  /// Clears the value of `imageAlternativeText`. Subsequent reads from it will return its default value.
  public mutating func clearImageAlternativeText() {self._imageAlternativeText = nil}

  /// Description of the cause of the alert that allows for agency-specific language; more specific than the Cause. If cause_detail is included, then Cause must also be included.
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var causeDetail: TransitRealtime_TranslatedString {
    get {return _causeDetail ?? TransitRealtime_TranslatedString()}
    set {_causeDetail = newValue}
  }
  /// Returns true if `causeDetail` has been explicitly set.
  public var hasCauseDetail: Bool {return self._causeDetail != nil}
  /// Clears the value of `causeDetail`. Subsequent reads from it will return its default value.
  public mutating func clearCauseDetail() {self._causeDetail = nil}

  /// Description of the effect of the alert that allows for agency-specific language; more specific than the Effect. If effect_detail is included, then Effect must also be included.
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var effectDetail: TransitRealtime_TranslatedString {
    get {return _effectDetail ?? TransitRealtime_TranslatedString()}
    set {_effectDetail = newValue}
  }
  /// Returns true if `effectDetail` has been explicitly set.
  public var hasEffectDetail: Bool {return self._effectDetail != nil}
  /// Clears the value of `effectDetail`. Subsequent reads from it will return its default value.
  public mutating func clearEffectDetail() {self._effectDetail = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Cause of this alert. If cause_detail is included, then Cause must also be included.
  public enum Cause: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknownCause = 1

    /// Not machine-representable.
    case otherCause = 2
    case technicalProblem = 3

    /// Public transit agency employees stopped working.
    case strike = 4

    /// People are blocking the streets.
    case demonstration = 5
    case accident = 6
    case holiday = 7
    case weather = 8
    case maintenance = 9
    case construction = 10
    case policeActivity = 11
    case medicalEmergency = 12

    public init() {
      self = .unknownCause
    }

  }

  /// What is the effect of this problem on the affected entity. If effect_detail is included, then Effect must also be included.
  public enum Effect: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case noService = 1
    case reducedService = 2

    /// We don't care about INsignificant delays: they are hard to detect, have
    /// little impact on the user, and would clutter the results as they are too
    /// frequent.
    case significantDelays = 3
    case detour = 4
    case additionalService = 5
    case modifiedService = 6
    case otherEffect = 7
    case unknownEffect = 8
    case stopMoved = 9
    case noEffect = 10
    case accessibilityIssue = 11

    public init() {
      self = .noService
    }

  }

  /// Severity of this alert.
  public enum SeverityLevel: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknownSeverity = 1
    case info = 2
    case warning = 3
    case severe = 4

    public init() {
      self = .unknownSeverity
    }

  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _cause: TransitRealtime_Alert.Cause? = nil
  fileprivate var _effect: TransitRealtime_Alert.Effect? = nil
  fileprivate var _url: TransitRealtime_TranslatedString? = nil
  fileprivate var _headerText: TransitRealtime_TranslatedString? = nil
  fileprivate var _descriptionText: TransitRealtime_TranslatedString? = nil
  fileprivate var _ttsHeaderText: TransitRealtime_TranslatedString? = nil
  fileprivate var _ttsDescriptionText: TransitRealtime_TranslatedString? = nil
  fileprivate var _severityLevel: TransitRealtime_Alert.SeverityLevel? = nil
  fileprivate var _image: TransitRealtime_TranslatedImage? = nil
  fileprivate var _imageAlternativeText: TransitRealtime_TranslatedString? = nil
  fileprivate var _causeDetail: TransitRealtime_TranslatedString? = nil
  fileprivate var _effectDetail: TransitRealtime_TranslatedString? = nil
}

/// A time interval. The interval is considered active at time 't' if 't' is
/// greater than or equal to the start time and less than the end time.
public struct TransitRealtime_TimeRange: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start time, in POSIX time (i.e., number of seconds since January 1st 1970
  /// 00:00:00 UTC).
  /// If missing, the interval starts at minus infinity.
  public var start: UInt64 {
    get {return _start ?? 0}
    set {_start = newValue}
  }
  /// Returns true if `start` has been explicitly set.
  public var hasStart: Bool {return self._start != nil}
  /// Clears the value of `start`. Subsequent reads from it will return its default value.
  public mutating func clearStart() {self._start = nil}

  /// End time, in POSIX time (i.e., number of seconds since January 1st 1970
  /// 00:00:00 UTC).
  /// If missing, the interval ends at plus infinity.
  public var end: UInt64 {
    get {return _end ?? 0}
    set {_end = newValue}
  }
  /// Returns true if `end` has been explicitly set.
  public var hasEnd: Bool {return self._end != nil}
  /// Clears the value of `end`. Subsequent reads from it will return its default value.
  public mutating func clearEnd() {self._end = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _start: UInt64? = nil
  fileprivate var _end: UInt64? = nil
}

/// A position.
public struct TransitRealtime_Position: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Degrees North, in the WGS-84 coordinate system.
  public var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  public var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  public mutating func clearLatitude() {self._latitude = nil}

  /// Degrees East, in the WGS-84 coordinate system.
  public var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  public var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  public mutating func clearLongitude() {self._longitude = nil}

  /// Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East.
  /// This can be the compass bearing, or the direction towards the next stop
  /// or intermediate location.
  /// This should not be direction deduced from the sequence of previous
  /// positions, which can be computed from previous data.
  public var bearing: Float {
    get {return _bearing ?? 0}
    set {_bearing = newValue}
  }
  /// Returns true if `bearing` has been explicitly set.
  public var hasBearing: Bool {return self._bearing != nil}
  /// Clears the value of `bearing`. Subsequent reads from it will return its default value.
  public mutating func clearBearing() {self._bearing = nil}

  /// Odometer value, in meters.
  public var odometer: Double {
    get {return _odometer ?? 0}
    set {_odometer = newValue}
  }
  /// Returns true if `odometer` has been explicitly set.
  public var hasOdometer: Bool {return self._odometer != nil}
  /// Clears the value of `odometer`. Subsequent reads from it will return its default value.
  public mutating func clearOdometer() {self._odometer = nil}

  /// Momentary speed measured by the vehicle, in meters per second.
  public var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  public var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  public mutating func clearSpeed() {self._speed = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _latitude: Float? = nil
  fileprivate var _longitude: Float? = nil
  fileprivate var _bearing: Float? = nil
  fileprivate var _odometer: Double? = nil
  fileprivate var _speed: Float? = nil
}

/// A descriptor that identifies an instance of a GTFS trip, or all instances of
/// a trip along a route.
/// - To specify a single trip instance, the trip_id (and if necessary,
///   start_time) is set. If route_id is also set, then it should be same as one
///   that the given trip corresponds to.
/// - To specify all the trips along a given route, only the route_id should be
///   set. Note that if the trip_id is not known, then stop sequence ids in
///   TripUpdate are not sufficient, and stop_ids must be provided as well. In
///   addition, absolute arrival/departure times must be provided.
public struct TransitRealtime_TripDescriptor: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The trip_id from the GTFS feed that this selector refers to.
  /// For non frequency-based trips, this field is enough to uniquely identify
  /// the trip. For frequency-based trip, start_time and start_date might also be
  /// necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from
  /// static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id
  /// identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id.
  public var tripID: String {
    get {return _tripID ?? String()}
    set {_tripID = newValue}
  }
  /// Returns true if `tripID` has been explicitly set.
  public var hasTripID: Bool {return self._tripID != nil}
  /// Clears the value of `tripID`. Subsequent reads from it will return its default value.
  public mutating func clearTripID() {self._tripID = nil}

  /// The route_id from the GTFS that this selector refers to.
  public var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  public var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  public mutating func clearRouteID() {self._routeID = nil}

  /// The direction_id from the GTFS feed trips.txt file, indicating the
  /// direction of travel for trips this selector refers to.
  public var directionID: UInt32 {
    get {return _directionID ?? 0}
    set {_directionID = newValue}
  }
  /// Returns true if `directionID` has been explicitly set.
  public var hasDirectionID: Bool {return self._directionID != nil}
  /// Clears the value of `directionID`. Subsequent reads from it will return its default value.
  public mutating func clearDirectionID() {self._directionID = nil}

  /// The initially scheduled start time of this trip instance.
  /// When the trip_id corresponds to a non-frequency-based trip, this field
  /// should either be omitted or be equal to the value in the GTFS feed. When
  /// the trip_id correponds to a frequency-based trip, the start_time must be
  /// specified for trip updates and vehicle positions. If the trip corresponds
  /// to exact_times=1 GTFS record, then start_time must be some multiple
  /// (including zero) of headway_secs later than frequencies.txt start_time for
  /// the corresponding time period. If the trip corresponds to exact_times=0,
  /// then its start_time may be arbitrary, and is initially expected to be the
  /// first departure of the trip. Once established, the start_time of this
  /// frequency-based trip should be considered immutable, even if the first
  /// departure time changes -- that time change may instead be reflected in a
  /// StopTimeUpdate.
  /// Format and semantics of the field is same as that of
  /// GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
  public var startTime: String {
    get {return _startTime ?? String()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  public var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  public mutating func clearStartTime() {self._startTime = nil}

  /// The scheduled start date of this trip instance.
  /// Must be provided to disambiguate trips that are so late as to collide with
  /// a scheduled trip on a next day. For example, for a train that departs 8:00
  /// and 20:00 every day, and is 12 hours late, there would be two distinct
  /// trips on the same time.
  /// This field can be provided but is not mandatory for schedules in which such
  /// collisions are impossible - for example, a service running on hourly
  /// schedule where a vehicle that is one hour late is not considered to be
  /// related to schedule anymore.
  /// In YYYYMMDD format.
  public var startDate: String {
    get {return _startDate ?? String()}
    set {_startDate = newValue}
  }
  /// Returns true if `startDate` has been explicitly set.
  public var hasStartDate: Bool {return self._startDate != nil}
  /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
  public mutating func clearStartDate() {self._startDate = nil}

  public var scheduleRelationship: TransitRealtime_TripDescriptor.ScheduleRelationship {
    get {return _scheduleRelationship ?? .scheduled}
    set {_scheduleRelationship = newValue}
  }
  /// Returns true if `scheduleRelationship` has been explicitly set.
  public var hasScheduleRelationship: Bool {return self._scheduleRelationship != nil}
  /// Clears the value of `scheduleRelationship`. Subsequent reads from it will return its default value.
  public mutating func clearScheduleRelationship() {self._scheduleRelationship = nil}

  /// Linkage to any modifications done to this trip (shape changes, removal or addition of stops).
  /// If this field is provided, the `trip_id`, `route_id`, `direction_id`, `start_time`, `start_date` fields of the `TripDescriptor` MUST be left empty, to avoid confusion by consumers that aren't looking for the `ModifiedTripSelector` value.
  public var modifiedTrip: TransitRealtime_TripDescriptor.ModifiedTripSelector {
    get {return _modifiedTrip ?? TransitRealtime_TripDescriptor.ModifiedTripSelector()}
    set {_modifiedTrip = newValue}
  }
  /// Returns true if `modifiedTrip` has been explicitly set.
  public var hasModifiedTrip: Bool {return self._modifiedTrip != nil}
  /// Clears the value of `modifiedTrip`. Subsequent reads from it will return its default value.
  public mutating func clearModifiedTrip() {self._modifiedTrip = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The relation between this trip and the static schedule. If a trip is done
  /// in accordance with temporary schedule, not reflected in GTFS, then it
  /// shouldn't be marked as SCHEDULED, but likely as ADDED.
  public enum ScheduleRelationship: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// Trip that is running in accordance with its GTFS schedule, or is close
    /// enough to the scheduled trip to be associated with it.
    case scheduled = 0

    /// This value has been deprecated as the behavior was unspecified. 
    /// Use DUPLICATED for an extra trip that is the same as a scheduled trip except the start date or time, 
    /// or NEW for an extra trip that is unrelated to an existing trip.
    ///
    /// NOTE: This enum value was marked as deprecated in the .proto file
    case added = 1

    /// A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0).
    /// Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED.
    case unscheduled = 2

    /// A trip that existed in the schedule but was removed.
    case canceled = 3

    /// A trip that replaces an existing trip in the schedule.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    case replacement = 5

    /// An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to
    /// respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date,
    /// and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service
    /// date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS
    /// (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is
    /// identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by
    /// TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate
    /// TripUpdate with the value of CANCELED or DELETED. If a producer wants to replace the original trip, a value of 
    /// `REPLACEMENT` should be used instead.
    ///
    /// Trips defined in GTFS frequencies.txt with exact_times that is
    /// empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain
    /// the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship
    /// must also be set to DUPLICATED.
    /// Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow
    /// the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md)
    /// to transition to the DUPLICATED enumeration.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    case duplicated = 6

    /// A trip that existed in the schedule but was removed and must not be shown to users.
    /// DELETED should be used instead of CANCELED to indicate that a transit provider would like to entirely remove
    /// information about the corresponding trip from consuming applications, so the trip is not shown as cancelled to
    /// riders, e.g. a trip that is entirely being replaced by another trip.
    /// This designation becomes particularly important if several trips are cancelled and replaced with substitute service.
    /// If consumers were to show explicit information about the cancellations it would distract from the more important
    /// real-time predictions.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    case deleted = 7

    /// An extra trip unrelated to any existing trips, for example, to respond to sudden passenger load.
    /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
    case new = 8

    public init() {
      self = .scheduled
    }

  }

  public struct ModifiedTripSelector: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The 'id' from the FeedEntity in which the contained TripModifications object affects this trip.
    public var modificationsID: String {
      get {return _modificationsID ?? String()}
      set {_modificationsID = newValue}
    }
    /// Returns true if `modificationsID` has been explicitly set.
    public var hasModificationsID: Bool {return self._modificationsID != nil}
    /// Clears the value of `modificationsID`. Subsequent reads from it will return its default value.
    public mutating func clearModificationsID() {self._modificationsID = nil}

    /// The trip_id from the GTFS feed that is modified by the modifications_id
    public var affectedTripID: String {
      get {return _affectedTripID ?? String()}
      set {_affectedTripID = newValue}
    }
    /// Returns true if `affectedTripID` has been explicitly set.
    public var hasAffectedTripID: Bool {return self._affectedTripID != nil}
    /// Clears the value of `affectedTripID`. Subsequent reads from it will return its default value.
    public mutating func clearAffectedTripID() {self._affectedTripID = nil}

    /// The initially scheduled start time of this trip instance, applied to the frequency based modified trip. Same definition as start_time in TripDescriptor.
    public var startTime: String {
      get {return _startTime ?? String()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {return self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// The start date of this trip instance in YYYYMMDD format, applied to the modified trip. Same definition as start_date in TripDescriptor.
    public var startDate: String {
      get {return _startDate ?? String()}
      set {_startDate = newValue}
    }
    /// Returns true if `startDate` has been explicitly set.
    public var hasStartDate: Bool {return self._startDate != nil}
    /// Clears the value of `startDate`. Subsequent reads from it will return its default value.
    public mutating func clearStartDate() {self._startDate = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _modificationsID: String? = nil
    fileprivate var _affectedTripID: String? = nil
    fileprivate var _startTime: String? = nil
    fileprivate var _startDate: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _tripID: String? = nil
  fileprivate var _routeID: String? = nil
  fileprivate var _directionID: UInt32? = nil
  fileprivate var _startTime: String? = nil
  fileprivate var _startDate: String? = nil
  fileprivate var _scheduleRelationship: TransitRealtime_TripDescriptor.ScheduleRelationship? = nil
  fileprivate var _modifiedTrip: TransitRealtime_TripDescriptor.ModifiedTripSelector? = nil
}

/// Identification information for the vehicle performing the trip.
public struct TransitRealtime_VehicleDescriptor: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Internal system identification of the vehicle. Should be unique per
  /// vehicle, and can be used for tracking the vehicle as it proceeds through
  /// the system.
  public var id: String {
    get {return _id ?? String()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  /// User visible label, i.e., something that must be shown to the passenger to
  /// help identify the correct vehicle.
  public var label: String {
    get {return _label ?? String()}
    set {_label = newValue}
  }
  /// Returns true if `label` has been explicitly set.
  public var hasLabel: Bool {return self._label != nil}
  /// Clears the value of `label`. Subsequent reads from it will return its default value.
  public mutating func clearLabel() {self._label = nil}

  /// The license plate of the vehicle.
  public var licensePlate: String {
    get {return _licensePlate ?? String()}
    set {_licensePlate = newValue}
  }
  /// Returns true if `licensePlate` has been explicitly set.
  public var hasLicensePlate: Bool {return self._licensePlate != nil}
  /// Clears the value of `licensePlate`. Subsequent reads from it will return its default value.
  public mutating func clearLicensePlate() {self._licensePlate = nil}

  public var wheelchairAccessible: TransitRealtime_VehicleDescriptor.WheelchairAccessible {
    get {return _wheelchairAccessible ?? .noValue}
    set {_wheelchairAccessible = newValue}
  }
  /// Returns true if `wheelchairAccessible` has been explicitly set.
  public var hasWheelchairAccessible: Bool {return self._wheelchairAccessible != nil}
  /// Clears the value of `wheelchairAccessible`. Subsequent reads from it will return its default value.
  public mutating func clearWheelchairAccessible() {self._wheelchairAccessible = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum WheelchairAccessible: Int, SwiftProtobuf.Enum, Swift.CaseIterable {

    /// The trip doesn't have information about wheelchair accessibility.
    /// This is the **default** behavior. If the static GTFS contains a
    /// _wheelchair_accessible_ value, it won't be overwritten.
    case noValue = 0

    /// The trip has no accessibility value present.
    /// This value will overwrite the value from the GTFS.
    case unknown = 1

    /// The trip is wheelchair accessible.
    /// This value will overwrite the value from the GTFS.
    case wheelchairAccessible = 2

    /// The trip is **not** wheelchair accessible.
    /// This value will overwrite the value from the GTFS.
    case wheelchairInaccessible = 3

    public init() {
      self = .noValue
    }

  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _id: String? = nil
  fileprivate var _label: String? = nil
  fileprivate var _licensePlate: String? = nil
  fileprivate var _wheelchairAccessible: TransitRealtime_VehicleDescriptor.WheelchairAccessible? = nil
}

/// A selector for an entity in a GTFS feed.
public struct TransitRealtime_EntitySelector: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The values of the fields should correspond to the appropriate fields in the
  /// GTFS feed.
  /// At least one specifier must be given. If several are given, then the
  /// matching has to apply to all the given specifiers.
  public var agencyID: String {
    get {return _agencyID ?? String()}
    set {_agencyID = newValue}
  }
  /// Returns true if `agencyID` has been explicitly set.
  public var hasAgencyID: Bool {return self._agencyID != nil}
  /// Clears the value of `agencyID`. Subsequent reads from it will return its default value.
  public mutating func clearAgencyID() {self._agencyID = nil}

  public var routeID: String {
    get {return _routeID ?? String()}
    set {_routeID = newValue}
  }
  /// Returns true if `routeID` has been explicitly set.
  public var hasRouteID: Bool {return self._routeID != nil}
  /// Clears the value of `routeID`. Subsequent reads from it will return its default value.
  public mutating func clearRouteID() {self._routeID = nil}

  /// corresponds to route_type in GTFS.
  public var routeType: Int32 {
    get {return _routeType ?? 0}
    set {_routeType = newValue}
  }
  /// Returns true if `routeType` has been explicitly set.
  public var hasRouteType: Bool {return self._routeType != nil}
  /// Clears the value of `routeType`. Subsequent reads from it will return its default value.
  public mutating func clearRouteType() {self._routeType = nil}

  public var trip: TransitRealtime_TripDescriptor {
    get {return _trip ?? TransitRealtime_TripDescriptor()}
    set {_trip = newValue}
  }
  /// Returns true if `trip` has been explicitly set.
  public var hasTrip: Bool {return self._trip != nil}
  /// Clears the value of `trip`. Subsequent reads from it will return its default value.
  public mutating func clearTrip() {self._trip = nil}

  public var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  public var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  public mutating func clearStopID() {self._stopID = nil}

  /// Corresponds to trip direction_id in GTFS trips.txt. If provided the
  /// route_id must also be provided.
  public var directionID: UInt32 {
    get {return _directionID ?? 0}
    set {_directionID = newValue}
  }
  /// Returns true if `directionID` has been explicitly set.
  public var hasDirectionID: Bool {return self._directionID != nil}
  /// Clears the value of `directionID`. Subsequent reads from it will return its default value.
  public mutating func clearDirectionID() {self._directionID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _agencyID: String? = nil
  fileprivate var _routeID: String? = nil
  fileprivate var _routeType: Int32? = nil
  fileprivate var _trip: TransitRealtime_TripDescriptor? = nil
  fileprivate var _stopID: String? = nil
  fileprivate var _directionID: UInt32? = nil
}

/// An internationalized message containing per-language versions of a snippet of
/// text or a URL.
/// One of the strings from a message will be picked up. The resolution proceeds
/// as follows:
/// 1. If the UI language matches the language code of a translation,
///    the first matching translation is picked.
/// 2. If a default UI language (e.g., English) matches the language code of a
///    translation, the first matching translation is picked.
/// 3. If some translation has an unspecified language code, that translation is
///    picked.
public struct TransitRealtime_TranslatedString: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// At least one translation must be provided.
  public var translation: [TransitRealtime_TranslatedString.Translation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Translation: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A UTF-8 string containing the message.
    public var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    public var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    public mutating func clearText() {self._text = nil}

    /// BCP-47 language code. Can be omitted if the language is unknown or if
    /// no i18n is done at all for the feed. At most one translation is
    /// allowed to have an unspecified language tag.
    public var language: String {
      get {return _language ?? String()}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {self._language = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _text: String? = nil
    fileprivate var _language: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

/// An internationalized image containing per-language versions of a URL linking to an image
/// along with meta information
/// Only one of the images from a message will be retained by consumers. The resolution proceeds
/// as follows:
/// 1. If the UI language matches the language code of a translation,
///    the first matching translation is picked.
/// 2. If a default UI language (e.g., English) matches the language code of a
///    translation, the first matching translation is picked.
/// 3. If some translation has an unspecified language code, that translation is
///    picked.
/// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
public struct TransitRealtime_TranslatedImage: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// At least one localized image must be provided.
  public var localizedImage: [TransitRealtime_TranslatedImage.LocalizedImage] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct LocalizedImage: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// String containing an URL linking to an image
    /// The image linked must be less than 2MB. 
    /// If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one.
    /// The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following http://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.
    public var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    public var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    public mutating func clearURL() {self._url = nil}

    /// IANA media type as to specify the type of image to be displayed. 
    /// The type must start with "image/"
    public var mediaType: String {
      get {return _mediaType ?? String()}
      set {_mediaType = newValue}
    }
    /// Returns true if `mediaType` has been explicitly set.
    public var hasMediaType: Bool {return self._mediaType != nil}
    /// Clears the value of `mediaType`. Subsequent reads from it will return its default value.
    public mutating func clearMediaType() {self._mediaType = nil}

    /// BCP-47 language code. Can be omitted if the language is unknown or if
    /// no i18n is done at all for the feed. At most one translation is
    /// allowed to have an unspecified language tag.
    public var language: String {
      get {return _language ?? String()}
      set {_language = newValue}
    }
    /// Returns true if `language` has been explicitly set.
    public var hasLanguage: Bool {return self._language != nil}
    /// Clears the value of `language`. Subsequent reads from it will return its default value.
    public mutating func clearLanguage() {self._language = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _url: String? = nil
    fileprivate var _mediaType: String? = nil
    fileprivate var _language: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

/// Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS,
/// such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points.
/// Tracing the points in order provides the path of the vehicle.  Shapes do not need to intercept
/// the location of Stops exactly, but all Stops on a trip should lie within a small distance of
/// the shape for that trip, i.e. close to straight line segments connecting the shape points
/// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
public struct TransitRealtime_Shape: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS.
  /// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
  /// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var shapeID: String {
    get {return _shapeID ?? String()}
    set {_shapeID = newValue}
  }
  /// Returns true if `shapeID` has been explicitly set.
  public var hasShapeID: Bool {return self._shapeID != nil}
  /// Clears the value of `shapeID`. Subsequent reads from it will return its default value.
  public mutating func clearShapeID() {self._shapeID = nil}

  /// Encoded polyline representation of the shape. This polyline must contain at least two points and represent the full shape of the trip where it's used. 
  /// For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm
  /// This field is required as per reference.md, but needs to be specified here optional because "Required is Forever"
  /// See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules
  /// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
  public var encodedPolyline: String {
    get {return _encodedPolyline ?? String()}
    set {_encodedPolyline = newValue}
  }
  /// Returns true if `encodedPolyline` has been explicitly set.
  public var hasEncodedPolyline: Bool {return self._encodedPolyline != nil}
  /// Clears the value of `encodedPolyline`. Subsequent reads from it will return its default value.
  public mutating func clearEncodedPolyline() {self._encodedPolyline = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _shapeID: String? = nil
  fileprivate var _encodedPolyline: String? = nil
}

/// Describes a stop which is served by trips. All fields are as described in the GTFS-Static specification.
/// NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future.
public struct TransitRealtime_Stop: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  public var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  public mutating func clearStopID() {self._stopID = nil}

  public var stopCode: TransitRealtime_TranslatedString {
    get {return _stopCode ?? TransitRealtime_TranslatedString()}
    set {_stopCode = newValue}
  }
  /// Returns true if `stopCode` has been explicitly set.
  public var hasStopCode: Bool {return self._stopCode != nil}
  /// Clears the value of `stopCode`. Subsequent reads from it will return its default value.
  public mutating func clearStopCode() {self._stopCode = nil}

  public var stopName: TransitRealtime_TranslatedString {
    get {return _stopName ?? TransitRealtime_TranslatedString()}
    set {_stopName = newValue}
  }
  /// Returns true if `stopName` has been explicitly set.
  public var hasStopName: Bool {return self._stopName != nil}
  /// Clears the value of `stopName`. Subsequent reads from it will return its default value.
  public mutating func clearStopName() {self._stopName = nil}

  public var ttsStopName: TransitRealtime_TranslatedString {
    get {return _ttsStopName ?? TransitRealtime_TranslatedString()}
    set {_ttsStopName = newValue}
  }
  /// Returns true if `ttsStopName` has been explicitly set.
  public var hasTtsStopName: Bool {return self._ttsStopName != nil}
  /// Clears the value of `ttsStopName`. Subsequent reads from it will return its default value.
  public mutating func clearTtsStopName() {self._ttsStopName = nil}

  public var stopDesc: TransitRealtime_TranslatedString {
    get {return _stopDesc ?? TransitRealtime_TranslatedString()}
    set {_stopDesc = newValue}
  }
  /// Returns true if `stopDesc` has been explicitly set.
  public var hasStopDesc: Bool {return self._stopDesc != nil}
  /// Clears the value of `stopDesc`. Subsequent reads from it will return its default value.
  public mutating func clearStopDesc() {self._stopDesc = nil}

  public var stopLat: Float {
    get {return _stopLat ?? 0}
    set {_stopLat = newValue}
  }
  /// Returns true if `stopLat` has been explicitly set.
  public var hasStopLat: Bool {return self._stopLat != nil}
  /// Clears the value of `stopLat`. Subsequent reads from it will return its default value.
  public mutating func clearStopLat() {self._stopLat = nil}

  public var stopLon: Float {
    get {return _stopLon ?? 0}
    set {_stopLon = newValue}
  }
  /// Returns true if `stopLon` has been explicitly set.
  public var hasStopLon: Bool {return self._stopLon != nil}
  /// Clears the value of `stopLon`. Subsequent reads from it will return its default value.
  public mutating func clearStopLon() {self._stopLon = nil}

  public var zoneID: String {
    get {return _zoneID ?? String()}
    set {_zoneID = newValue}
  }
  /// Returns true if `zoneID` has been explicitly set.
  public var hasZoneID: Bool {return self._zoneID != nil}
  /// Clears the value of `zoneID`. Subsequent reads from it will return its default value.
  public mutating func clearZoneID() {self._zoneID = nil}

  public var stopURL: TransitRealtime_TranslatedString {
    get {return _stopURL ?? TransitRealtime_TranslatedString()}
    set {_stopURL = newValue}
  }
  /// Returns true if `stopURL` has been explicitly set.
  public var hasStopURL: Bool {return self._stopURL != nil}
  /// Clears the value of `stopURL`. Subsequent reads from it will return its default value.
  public mutating func clearStopURL() {self._stopURL = nil}

  public var parentStation: String {
    get {return _parentStation ?? String()}
    set {_parentStation = newValue}
  }
  /// Returns true if `parentStation` has been explicitly set.
  public var hasParentStation: Bool {return self._parentStation != nil}
  /// Clears the value of `parentStation`. Subsequent reads from it will return its default value.
  public mutating func clearParentStation() {self._parentStation = nil}

  public var stopTimezone: String {
    get {return _stopTimezone ?? String()}
    set {_stopTimezone = newValue}
  }
  /// Returns true if `stopTimezone` has been explicitly set.
  public var hasStopTimezone: Bool {return self._stopTimezone != nil}
  /// Clears the value of `stopTimezone`. Subsequent reads from it will return its default value.
  public mutating func clearStopTimezone() {self._stopTimezone = nil}

  public var wheelchairBoarding: TransitRealtime_Stop.WheelchairBoarding {
    get {return _wheelchairBoarding ?? .unknown}
    set {_wheelchairBoarding = newValue}
  }
  /// Returns true if `wheelchairBoarding` has been explicitly set.
  public var hasWheelchairBoarding: Bool {return self._wheelchairBoarding != nil}
  /// Clears the value of `wheelchairBoarding`. Subsequent reads from it will return its default value.
  public mutating func clearWheelchairBoarding() {self._wheelchairBoarding = nil}

  public var levelID: String {
    get {return _levelID ?? String()}
    set {_levelID = newValue}
  }
  /// Returns true if `levelID` has been explicitly set.
  public var hasLevelID: Bool {return self._levelID != nil}
  /// Clears the value of `levelID`. Subsequent reads from it will return its default value.
  public mutating func clearLevelID() {self._levelID = nil}

  public var platformCode: TransitRealtime_TranslatedString {
    get {return _platformCode ?? TransitRealtime_TranslatedString()}
    set {_platformCode = newValue}
  }
  /// Returns true if `platformCode` has been explicitly set.
  public var hasPlatformCode: Bool {return self._platformCode != nil}
  /// Clears the value of `platformCode`. Subsequent reads from it will return its default value.
  public mutating func clearPlatformCode() {self._platformCode = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum WheelchairBoarding: Int, SwiftProtobuf.Enum, Swift.CaseIterable {
    case unknown = 0
    case available = 1
    case notAvailable = 2

    public init() {
      self = .unknown
    }

  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _stopID: String? = nil
  fileprivate var _stopCode: TransitRealtime_TranslatedString? = nil
  fileprivate var _stopName: TransitRealtime_TranslatedString? = nil
  fileprivate var _ttsStopName: TransitRealtime_TranslatedString? = nil
  fileprivate var _stopDesc: TransitRealtime_TranslatedString? = nil
  fileprivate var _stopLat: Float? = nil
  fileprivate var _stopLon: Float? = nil
  fileprivate var _zoneID: String? = nil
  fileprivate var _stopURL: TransitRealtime_TranslatedString? = nil
  fileprivate var _parentStation: String? = nil
  fileprivate var _stopTimezone: String? = nil
  fileprivate var _wheelchairBoarding: TransitRealtime_Stop.WheelchairBoarding? = nil
  fileprivate var _levelID: String? = nil
  fileprivate var _platformCode: TransitRealtime_TranslatedString? = nil
}

/// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
public struct TransitRealtime_TripModifications: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of selected trips affected by this TripModifications.
  public var selectedTrips: [TransitRealtime_TripModifications.SelectedTrips] = []

  /// A list of start times in the real-time trip descriptor for the trip_id defined in trip_ids. 
  /// Useful to target multiple departures of a trip_id in a frequency-based trip.
  public var startTimes: [String] = []

  /// Dates on which the modifications occurs, in the YYYYMMDD format. Producers SHOULD only transmit detours occurring within the next week.
  /// The dates provided should not be used as user-facing information, if a user-facing start and end date needs to be provided, they can be provided in the linked service alert with `service_alert_id`
  public var serviceDates: [String] = []

  /// A list of modifications to apply to the affected trips. 
  public var modifications: [TransitRealtime_TripModifications.Modification] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// A `Modification` message replaces a span of n stop times from each affected trip starting at `start_stop_selector`.
  public struct Modification: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The stop selector of the first stop_time of the original trip that is to be affected by this modification.
    /// Used in conjuction with `end_stop_selector`. 
    /// `start_stop_selector` is required and is used to define the reference stop used with `travel_time_to_stop`.
    public var startStopSelector: TransitRealtime_StopSelector {
      get {return _startStopSelector ?? TransitRealtime_StopSelector()}
      set {_startStopSelector = newValue}
    }
    /// Returns true if `startStopSelector` has been explicitly set.
    public var hasStartStopSelector: Bool {return self._startStopSelector != nil}
    /// Clears the value of `startStopSelector`. Subsequent reads from it will return its default value.
    public mutating func clearStartStopSelector() {self._startStopSelector = nil}

    /// The stop selector of the last stop of the original trip that is to be affected by this modification. 
    /// The selection is inclusive, so if only one stop_time is replaced by that modification, `start_stop_selector` and `end_stop_selector` must be equivalent.
    /// If no stop_time is replaced, `end_stop_selector` must not be provided. It's otherwise required.
    public var endStopSelector: TransitRealtime_StopSelector {
      get {return _endStopSelector ?? TransitRealtime_StopSelector()}
      set {_endStopSelector = newValue}
    }
    /// Returns true if `endStopSelector` has been explicitly set.
    public var hasEndStopSelector: Bool {return self._endStopSelector != nil}
    /// Clears the value of `endStopSelector`. Subsequent reads from it will return its default value.
    public mutating func clearEndStopSelector() {self._endStopSelector = nil}

    /// The number of seconds of delay to add to all departure and arrival times following the end of this modification. 
    /// If multiple modifications apply to the same trip, the delays accumulate as the trip advances. 
    public var propagatedModificationDelay: Int32 {
      get {return _propagatedModificationDelay ?? 0}
      set {_propagatedModificationDelay = newValue}
    }
    /// Returns true if `propagatedModificationDelay` has been explicitly set.
    public var hasPropagatedModificationDelay: Bool {return self._propagatedModificationDelay != nil}
    /// Clears the value of `propagatedModificationDelay`. Subsequent reads from it will return its default value.
    public mutating func clearPropagatedModificationDelay() {self._propagatedModificationDelay = nil}

    /// A list of replacement stops, replacing those of the original trip. 
    /// The length of the new stop times may be less, the same, or greater than the number of replaced stop times. 
    public var replacementStops: [TransitRealtime_ReplacementStop] = []

    /// An `id` value from the `FeedEntity` message that contains the `Alert` describing this Modification for user-facing communication.
    public var serviceAlertID: String {
      get {return _serviceAlertID ?? String()}
      set {_serviceAlertID = newValue}
    }
    /// Returns true if `serviceAlertID` has been explicitly set.
    public var hasServiceAlertID: Bool {return self._serviceAlertID != nil}
    /// Clears the value of `serviceAlertID`. Subsequent reads from it will return its default value.
    public mutating func clearServiceAlertID() {self._serviceAlertID = nil}

    /// This timestamp identifies the moment when the modification has last been changed.
    /// In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
    public var lastModifiedTime: UInt64 {
      get {return _lastModifiedTime ?? 0}
      set {_lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    public var hasLastModifiedTime: Bool {return self._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastModifiedTime() {self._lastModifiedTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _startStopSelector: TransitRealtime_StopSelector? = nil
    fileprivate var _endStopSelector: TransitRealtime_StopSelector? = nil
    fileprivate var _propagatedModificationDelay: Int32? = nil
    fileprivate var _serviceAlertID: String? = nil
    fileprivate var _lastModifiedTime: UInt64? = nil
  }

  public struct SelectedTrips: SwiftProtobuf.ExtensibleMessage, Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A list of trips affected with this replacement that all have the same new `shape_id`. A `TripUpdate` with `schedule_relationship=REPLACEMENT` must not already exist for the trip.
    public var tripIds: [String] = []

    /// The ID of the new shape for the modified trips in this SelectedTrips. 
    /// May refer to a new shape added using a `Shape` message in the same GTFS-RT feed, or to an existing shape defined in the GTFS-Static feed’s shapes.txt. 
    /// If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `shape_id` inside the entity, and _not_ the `id` of `FeedEntity`.
    public var shapeID: String {
      get {return _shapeID ?? String()}
      set {_shapeID = newValue}
    }
    /// Returns true if `shapeID` has been explicitly set.
    public var hasShapeID: Bool {return self._shapeID != nil}
    /// Clears the value of `shapeID`. Subsequent reads from it will return its default value.
    public mutating func clearShapeID() {self._shapeID = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
    fileprivate var _shapeID: String? = nil
  }

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
}

/// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
/// Select a stop by stop sequence or by stop_id. At least one of the two values must be provided.
public struct TransitRealtime_StopSelector: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must be the same as in stop_times.txt in the corresponding GTFS feed.
  public var stopSequence: UInt32 {
    get {return _stopSequence ?? 0}
    set {_stopSequence = newValue}
  }
  /// Returns true if `stopSequence` has been explicitly set.
  public var hasStopSequence: Bool {return self._stopSequence != nil}
  /// Clears the value of `stopSequence`. Subsequent reads from it will return its default value.
  public mutating func clearStopSequence() {self._stopSequence = nil}

  /// Must be the same as in stops.txt in the corresponding GTFS feed.
  public var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  public var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  public mutating func clearStopID() {self._stopID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _stopSequence: UInt32? = nil
  fileprivate var _stopID: String? = nil
}

/// NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future.
public struct TransitRealtime_ReplacementStop: SwiftProtobuf.ExtensibleMessage, Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The difference in seconds between the arrival time at this stop and the arrival time at the reference stop. The reference stop is the stop prior to start_stop_selector. If the modification begins at the first stop of the trip, then the first stop of the trip is the reference stop.
  /// This value MUST be monotonically increasing and may only be a negative number if the first stop of the original trip is the reference stop.
  public var travelTimeToStop: Int32 {
    get {return _travelTimeToStop ?? 0}
    set {_travelTimeToStop = newValue}
  }
  /// Returns true if `travelTimeToStop` has been explicitly set.
  public var hasTravelTimeToStop: Bool {return self._travelTimeToStop != nil}
  /// Clears the value of `travelTimeToStop`. Subsequent reads from it will return its default value.
  public mutating func clearTravelTimeToStop() {self._travelTimeToStop = nil}

  /// The replacement stop ID which will now be visited by the trip. May refer to a new stop added using a GTFS-RT `Stop` message in the same GTFS-RT feed, or to an existing stop defined in the (CSV) GTFS feed’s `stops.txt`.
  /// If it refers to a `Shape` entity in the real-time feed, the value of this field should be the one of the `stop_id` inside the entity, and _not_ the `id` of `FeedEntity`. The replacement stop MUST have `location_type=0` (routable stops).
  public var stopID: String {
    get {return _stopID ?? String()}
    set {_stopID = newValue}
  }
  /// Returns true if `stopID` has been explicitly set.
  public var hasStopID: Bool {return self._stopID != nil}
  /// Clears the value of `stopID`. Subsequent reads from it will return its default value.
  public mutating func clearStopID() {self._stopID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  public var _protobuf_extensionFieldValues = SwiftProtobuf.ExtensionFieldValueSet()
  fileprivate var _travelTimeToStop: Int32? = nil
  fileprivate var _stopID: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "transit_realtime"

extension TransitRealtime_FeedMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "entity"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._header == nil {return false}
    if let v = self._header, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.entity) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entity) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedMessage.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.entity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entity, fieldNumber: 2)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_FeedMessage, rhs: TransitRealtime_FeedMessage) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.entity != rhs.entity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_FeedHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gtfs_realtime_version"),
    2: .same(proto: "incrementality"),
    3: .same(proto: "timestamp"),
    4: .standard(proto: "feed_version"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._gtfsRealtimeVersion == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._gtfsRealtimeVersion) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._incrementality) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._feedVersion) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedHeader.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gtfsRealtimeVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._incrementality {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._feedVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_FeedHeader, rhs: TransitRealtime_FeedHeader) -> Bool {
    if lhs._gtfsRealtimeVersion != rhs._gtfsRealtimeVersion {return false}
    if lhs._incrementality != rhs._incrementality {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._feedVersion != rhs._feedVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_FeedHeader.Incrementality: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FULL_DATASET"),
    1: .same(proto: "DIFFERENTIAL"),
  ]
}

extension TransitRealtime_FeedEntity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FeedEntity"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "is_deleted"),
    3: .standard(proto: "trip_update"),
    4: .same(proto: "vehicle"),
    5: .same(proto: "alert"),
    6: .same(proto: "shape"),
    7: .same(proto: "stop"),
    8: .standard(proto: "trip_modifications"),
  ]

  fileprivate class _StorageClass {
    var _id: String? = nil
    var _isDeleted: Bool? = nil
    var _tripUpdate: TransitRealtime_TripUpdate? = nil
    var _vehicle: TransitRealtime_VehiclePosition? = nil
    var _alert: TransitRealtime_Alert? = nil
    var _shape: TransitRealtime_Shape? = nil
    var _stop: TransitRealtime_Stop? = nil
    var _tripModifications: TransitRealtime_TripModifications? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _isDeleted = source._isDeleted
      _tripUpdate = source._tripUpdate
      _vehicle = source._vehicle
      _alert = source._alert
      _shape = source._shape
      _stop = source._stop
      _tripModifications = source._tripModifications
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id == nil {return false}
      if let v = _storage._tripUpdate, !v.isInitialized {return false}
      if let v = _storage._vehicle, !v.isInitialized {return false}
      if let v = _storage._alert, !v.isInitialized {return false}
      if let v = _storage._shape, !v.isInitialized {return false}
      if let v = _storage._stop, !v.isInitialized {return false}
      if let v = _storage._tripModifications, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._isDeleted) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._tripUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._vehicle) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._alert) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._shape) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._stop) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._tripModifications) }()
        case 1000..<2000, 9000..<10000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_FeedEntity.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._id {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._isDeleted {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tripUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._vehicle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._alert {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._shape {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._stop {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tripModifications {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_FeedEntity, rhs: TransitRealtime_FeedEntity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._isDeleted != rhs_storage._isDeleted {return false}
        if _storage._tripUpdate != rhs_storage._tripUpdate {return false}
        if _storage._vehicle != rhs_storage._vehicle {return false}
        if _storage._alert != rhs_storage._alert {return false}
        if _storage._shape != rhs_storage._shape {return false}
        if _storage._stop != rhs_storage._stop {return false}
        if _storage._tripModifications != rhs_storage._tripModifications {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TripUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trip"),
    3: .same(proto: "vehicle"),
    2: .standard(proto: "stop_time_update"),
    4: .same(proto: "timestamp"),
    5: .same(proto: "delay"),
    6: .standard(proto: "trip_properties"),
  ]

  fileprivate class _StorageClass {
    var _trip: TransitRealtime_TripDescriptor? = nil
    var _vehicle: TransitRealtime_VehicleDescriptor? = nil
    var _stopTimeUpdate: [TransitRealtime_TripUpdate.StopTimeUpdate] = []
    var _timestamp: UInt64? = nil
    var _delay: Int32? = nil
    var _tripProperties: TransitRealtime_TripUpdate.TripProperties? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trip = source._trip
      _vehicle = source._vehicle
      _stopTimeUpdate = source._stopTimeUpdate
      _timestamp = source._timestamp
      _delay = source._delay
      _tripProperties = source._tripProperties
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._trip == nil {return false}
      if let v = _storage._trip, !v.isInitialized {return false}
      if let v = _storage._vehicle, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._stopTimeUpdate) {return false}
      if let v = _storage._tripProperties, !v.isInitialized {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._trip) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._stopTimeUpdate) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._vehicle) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._delay) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._tripProperties) }()
        case 1000..<2000, 9000..<10000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._trip {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._stopTimeUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._stopTimeUpdate, fieldNumber: 2)
      }
      try { if let v = _storage._vehicle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._delay {
        try visitor.visitSingularInt32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._tripProperties {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripUpdate, rhs: TransitRealtime_TripUpdate) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trip != rhs_storage._trip {return false}
        if _storage._vehicle != rhs_storage._vehicle {return false}
        if _storage._stopTimeUpdate != rhs_storage._stopTimeUpdate {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._delay != rhs_storage._delay {return false}
        if _storage._tripProperties != rhs_storage._tripProperties {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripUpdate.protoMessageName + ".StopTimeEvent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "delay"),
    2: .same(proto: "time"),
    3: .same(proto: "uncertainty"),
    4: .standard(proto: "scheduled_time"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._delay) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self._time) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._uncertainty) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._scheduledTime) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.StopTimeEvent.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._delay {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._uncertainty {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._scheduledTime {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripUpdate.StopTimeEvent, rhs: TransitRealtime_TripUpdate.StopTimeEvent) -> Bool {
    if lhs._delay != rhs._delay {return false}
    if lhs._time != rhs._time {return false}
    if lhs._uncertainty != rhs._uncertainty {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripUpdate.protoMessageName + ".StopTimeUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_sequence"),
    4: .standard(proto: "stop_id"),
    2: .same(proto: "arrival"),
    3: .same(proto: "departure"),
    7: .standard(proto: "departure_occupancy_status"),
    5: .standard(proto: "schedule_relationship"),
    6: .standard(proto: "stop_time_properties"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._arrival, !v.isInitialized {return false}
    if let v = self._departure, !v.isInitialized {return false}
    if let v = self._stopTimeProperties, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._stopSequence) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._arrival) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._departure) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._scheduleRelationship) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._stopTimeProperties) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._departureOccupancyStatus) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.StopTimeUpdate.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stopSequence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._arrival {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._departure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scheduleRelationship {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._stopTimeProperties {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._departureOccupancyStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripUpdate.StopTimeUpdate, rhs: TransitRealtime_TripUpdate.StopTimeUpdate) -> Bool {
    if lhs._stopSequence != rhs._stopSequence {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs._arrival != rhs._arrival {return false}
    if lhs._departure != rhs._departure {return false}
    if lhs._departureOccupancyStatus != rhs._departureOccupancyStatus {return false}
    if lhs._scheduleRelationship != rhs._scheduleRelationship {return false}
    if lhs._stopTimeProperties != rhs._stopTimeProperties {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate.ScheduleRelationship: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCHEDULED"),
    1: .same(proto: "SKIPPED"),
    2: .same(proto: "NO_DATA"),
    3: .same(proto: "UNSCHEDULED"),
  ]
}

extension TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripUpdate.StopTimeUpdate.protoMessageName + ".StopTimeProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "assigned_stop_id"),
    2: .standard(proto: "stop_headsign"),
    3: .standard(proto: "pickup_type"),
    4: .standard(proto: "drop_off_type"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._assignedStopID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stopHeadsign) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._pickupType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._dropOffType) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._assignedStopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopHeadsign {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pickupType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dropOffType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties, rhs: TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties) -> Bool {
    if lhs._assignedStopID != rhs._assignedStopID {return false}
    if lhs._stopHeadsign != rhs._stopHeadsign {return false}
    if lhs._pickupType != rhs._pickupType {return false}
    if lhs._dropOffType != rhs._dropOffType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripUpdate.StopTimeUpdate.StopTimeProperties.DropOffPickupType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGULAR"),
    1: .same(proto: "NONE"),
    2: .same(proto: "PHONE_AGENCY"),
    3: .same(proto: "COORDINATE_WITH_DRIVER"),
  ]
}

extension TransitRealtime_TripUpdate.TripProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripUpdate.protoMessageName + ".TripProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trip_id"),
    2: .standard(proto: "start_date"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "shape_id"),
    5: .standard(proto: "trip_headsign"),
    6: .standard(proto: "trip_short_name"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tripID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._startDate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._shapeID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._tripHeadsign) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._tripShortName) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripUpdate.TripProperties.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tripID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startDate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._shapeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tripHeadsign {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._tripShortName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripUpdate.TripProperties, rhs: TransitRealtime_TripUpdate.TripProperties) -> Bool {
    if lhs._tripID != rhs._tripID {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._shapeID != rhs._shapeID {return false}
    if lhs._tripHeadsign != rhs._tripHeadsign {return false}
    if lhs._tripShortName != rhs._tripShortName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_VehiclePosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehiclePosition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "trip"),
    8: .same(proto: "vehicle"),
    2: .same(proto: "position"),
    3: .standard(proto: "current_stop_sequence"),
    7: .standard(proto: "stop_id"),
    4: .standard(proto: "current_status"),
    5: .same(proto: "timestamp"),
    6: .standard(proto: "congestion_level"),
    9: .standard(proto: "occupancy_status"),
    10: .standard(proto: "occupancy_percentage"),
    11: .standard(proto: "multi_carriage_details"),
  ]

  fileprivate class _StorageClass {
    var _trip: TransitRealtime_TripDescriptor? = nil
    var _vehicle: TransitRealtime_VehicleDescriptor? = nil
    var _position: TransitRealtime_Position? = nil
    var _currentStopSequence: UInt32? = nil
    var _stopID: String? = nil
    var _currentStatus: TransitRealtime_VehiclePosition.VehicleStopStatus? = nil
    var _timestamp: UInt64? = nil
    var _congestionLevel: TransitRealtime_VehiclePosition.CongestionLevel? = nil
    var _occupancyStatus: TransitRealtime_VehiclePosition.OccupancyStatus? = nil
    var _occupancyPercentage: UInt32? = nil
    var _multiCarriageDetails: [TransitRealtime_VehiclePosition.CarriageDetails] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _trip = source._trip
      _vehicle = source._vehicle
      _position = source._position
      _currentStopSequence = source._currentStopSequence
      _stopID = source._stopID
      _currentStatus = source._currentStatus
      _timestamp = source._timestamp
      _congestionLevel = source._congestionLevel
      _occupancyStatus = source._occupancyStatus
      _occupancyPercentage = source._occupancyPercentage
      _multiCarriageDetails = source._multiCarriageDetails
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._trip, !v.isInitialized {return false}
      if let v = _storage._vehicle, !v.isInitialized {return false}
      if let v = _storage._position, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._multiCarriageDetails) {return false}
      return true
    }
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._trip) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._position) }()
        case 3: try { try decoder.decodeSingularUInt32Field(value: &_storage._currentStopSequence) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._currentStatus) }()
        case 5: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._congestionLevel) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._stopID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._vehicle) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._occupancyStatus) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._occupancyPercentage) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._multiCarriageDetails) }()
        case 1000..<2000, 9000..<10000:
          try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_VehiclePosition.self, fieldNumber: fieldNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._trip {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._position {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._currentStopSequence {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._currentStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._congestionLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._stopID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._vehicle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._occupancyStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._occupancyPercentage {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      if !_storage._multiCarriageDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._multiCarriageDetails, fieldNumber: 11)
      }
      try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_VehiclePosition, rhs: TransitRealtime_VehiclePosition) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._trip != rhs_storage._trip {return false}
        if _storage._vehicle != rhs_storage._vehicle {return false}
        if _storage._position != rhs_storage._position {return false}
        if _storage._currentStopSequence != rhs_storage._currentStopSequence {return false}
        if _storage._stopID != rhs_storage._stopID {return false}
        if _storage._currentStatus != rhs_storage._currentStatus {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._congestionLevel != rhs_storage._congestionLevel {return false}
        if _storage._occupancyStatus != rhs_storage._occupancyStatus {return false}
        if _storage._occupancyPercentage != rhs_storage._occupancyPercentage {return false}
        if _storage._multiCarriageDetails != rhs_storage._multiCarriageDetails {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_VehiclePosition.VehicleStopStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INCOMING_AT"),
    1: .same(proto: "STOPPED_AT"),
    2: .same(proto: "IN_TRANSIT_TO"),
  ]
}

extension TransitRealtime_VehiclePosition.CongestionLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_CONGESTION_LEVEL"),
    1: .same(proto: "RUNNING_SMOOTHLY"),
    2: .same(proto: "STOP_AND_GO"),
    3: .same(proto: "CONGESTION"),
    4: .same(proto: "SEVERE_CONGESTION"),
  ]
}

extension TransitRealtime_VehiclePosition.OccupancyStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EMPTY"),
    1: .same(proto: "MANY_SEATS_AVAILABLE"),
    2: .same(proto: "FEW_SEATS_AVAILABLE"),
    3: .same(proto: "STANDING_ROOM_ONLY"),
    4: .same(proto: "CRUSHED_STANDING_ROOM_ONLY"),
    5: .same(proto: "FULL"),
    6: .same(proto: "NOT_ACCEPTING_PASSENGERS"),
    7: .same(proto: "NO_DATA_AVAILABLE"),
    8: .same(proto: "NOT_BOARDABLE"),
  ]
}

extension TransitRealtime_VehiclePosition.CarriageDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_VehiclePosition.protoMessageName + ".CarriageDetails"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .standard(proto: "occupancy_status"),
    4: .standard(proto: "occupancy_percentage"),
    5: .standard(proto: "carriage_sequence"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._occupancyStatus) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._occupancyPercentage) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._carriageSequence) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_VehiclePosition.CarriageDetails.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._occupancyStatus {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._occupancyPercentage {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._carriageSequence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_VehiclePosition.CarriageDetails, rhs: TransitRealtime_VehiclePosition.CarriageDetails) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._label != rhs._label {return false}
    if lhs._occupancyStatus != rhs._occupancyStatus {return false}
    if lhs._occupancyPercentage != rhs._occupancyPercentage {return false}
    if lhs._carriageSequence != rhs._carriageSequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Alert"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "active_period"),
    5: .standard(proto: "informed_entity"),
    6: .same(proto: "cause"),
    7: .same(proto: "effect"),
    8: .same(proto: "url"),
    10: .standard(proto: "header_text"),
    11: .standard(proto: "description_text"),
    12: .standard(proto: "tts_header_text"),
    13: .standard(proto: "tts_description_text"),
    14: .standard(proto: "severity_level"),
    15: .same(proto: "image"),
    16: .standard(proto: "image_alternative_text"),
    17: .standard(proto: "cause_detail"),
    18: .standard(proto: "effect_detail"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.activePeriod) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.informedEntity) {return false}
    if let v = self._url, !v.isInitialized {return false}
    if let v = self._headerText, !v.isInitialized {return false}
    if let v = self._descriptionText, !v.isInitialized {return false}
    if let v = self._ttsHeaderText, !v.isInitialized {return false}
    if let v = self._ttsDescriptionText, !v.isInitialized {return false}
    if let v = self._image, !v.isInitialized {return false}
    if let v = self._imageAlternativeText, !v.isInitialized {return false}
    if let v = self._causeDetail, !v.isInitialized {return false}
    if let v = self._effectDetail, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activePeriod) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.informedEntity) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._cause) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._effect) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._url) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._headerText) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._descriptionText) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._ttsHeaderText) }()
      case 13: try { try decoder.decodeSingularMessageField(value: &self._ttsDescriptionText) }()
      case 14: try { try decoder.decodeSingularEnumField(value: &self._severityLevel) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      case 16: try { try decoder.decodeSingularMessageField(value: &self._imageAlternativeText) }()
      case 17: try { try decoder.decodeSingularMessageField(value: &self._causeDetail) }()
      case 18: try { try decoder.decodeSingularMessageField(value: &self._effectDetail) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Alert.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.activePeriod.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activePeriod, fieldNumber: 1)
    }
    if !self.informedEntity.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.informedEntity, fieldNumber: 5)
    }
    try { if let v = self._cause {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._effect {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._url {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._headerText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._descriptionText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._ttsHeaderText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._ttsDescriptionText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._severityLevel {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try { if let v = self._imageAlternativeText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    } }()
    try { if let v = self._causeDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    } }()
    try { if let v = self._effectDetail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_Alert, rhs: TransitRealtime_Alert) -> Bool {
    if lhs.activePeriod != rhs.activePeriod {return false}
    if lhs.informedEntity != rhs.informedEntity {return false}
    if lhs._cause != rhs._cause {return false}
    if lhs._effect != rhs._effect {return false}
    if lhs._url != rhs._url {return false}
    if lhs._headerText != rhs._headerText {return false}
    if lhs._descriptionText != rhs._descriptionText {return false}
    if lhs._ttsHeaderText != rhs._ttsHeaderText {return false}
    if lhs._ttsDescriptionText != rhs._ttsDescriptionText {return false}
    if lhs._severityLevel != rhs._severityLevel {return false}
    if lhs._image != rhs._image {return false}
    if lhs._imageAlternativeText != rhs._imageAlternativeText {return false}
    if lhs._causeDetail != rhs._causeDetail {return false}
    if lhs._effectDetail != rhs._effectDetail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Alert.Cause: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_CAUSE"),
    2: .same(proto: "OTHER_CAUSE"),
    3: .same(proto: "TECHNICAL_PROBLEM"),
    4: .same(proto: "STRIKE"),
    5: .same(proto: "DEMONSTRATION"),
    6: .same(proto: "ACCIDENT"),
    7: .same(proto: "HOLIDAY"),
    8: .same(proto: "WEATHER"),
    9: .same(proto: "MAINTENANCE"),
    10: .same(proto: "CONSTRUCTION"),
    11: .same(proto: "POLICE_ACTIVITY"),
    12: .same(proto: "MEDICAL_EMERGENCY"),
  ]
}

extension TransitRealtime_Alert.Effect: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NO_SERVICE"),
    2: .same(proto: "REDUCED_SERVICE"),
    3: .same(proto: "SIGNIFICANT_DELAYS"),
    4: .same(proto: "DETOUR"),
    5: .same(proto: "ADDITIONAL_SERVICE"),
    6: .same(proto: "MODIFIED_SERVICE"),
    7: .same(proto: "OTHER_EFFECT"),
    8: .same(proto: "UNKNOWN_EFFECT"),
    9: .same(proto: "STOP_MOVED"),
    10: .same(proto: "NO_EFFECT"),
    11: .same(proto: "ACCESSIBILITY_ISSUE"),
  ]
}

extension TransitRealtime_Alert.SeverityLevel: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_SEVERITY"),
    2: .same(proto: "INFO"),
    3: .same(proto: "WARNING"),
    4: .same(proto: "SEVERE"),
  ]
}

extension TransitRealtime_TimeRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "start"),
    2: .same(proto: "end"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._start) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._end) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TimeRange.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._start {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._end {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TimeRange, rhs: TransitRealtime_TimeRange) -> Bool {
    if lhs._start != rhs._start {return false}
    if lhs._end != rhs._end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Position: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Position"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "bearing"),
    4: .same(proto: "odometer"),
    5: .same(proto: "speed"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._bearing) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._odometer) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._speed) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Position.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bearing {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._odometer {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_Position, rhs: TransitRealtime_Position) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._bearing != rhs._bearing {return false}
    if lhs._odometer != rhs._odometer {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TripDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trip_id"),
    5: .standard(proto: "route_id"),
    6: .standard(proto: "direction_id"),
    2: .standard(proto: "start_time"),
    3: .standard(proto: "start_date"),
    4: .standard(proto: "schedule_relationship"),
    7: .standard(proto: "modified_trip"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._modifiedTrip, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._tripID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._startTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._startDate) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._scheduleRelationship) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._directionID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._modifiedTrip) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripDescriptor.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tripID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startDate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._scheduleRelationship {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._directionID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._modifiedTrip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripDescriptor, rhs: TransitRealtime_TripDescriptor) -> Bool {
    if lhs._tripID != rhs._tripID {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._directionID != rhs._directionID {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs._scheduleRelationship != rhs._scheduleRelationship {return false}
    if lhs._modifiedTrip != rhs._modifiedTrip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripDescriptor.ScheduleRelationship: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SCHEDULED"),
    1: .same(proto: "ADDED"),
    2: .same(proto: "UNSCHEDULED"),
    3: .same(proto: "CANCELED"),
    5: .same(proto: "REPLACEMENT"),
    6: .same(proto: "DUPLICATED"),
    7: .same(proto: "DELETED"),
    8: .same(proto: "NEW"),
  ]
}

extension TransitRealtime_TripDescriptor.ModifiedTripSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripDescriptor.protoMessageName + ".ModifiedTripSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "modifications_id"),
    2: .standard(proto: "affected_trip_id"),
    3: .standard(proto: "start_time"),
    4: .standard(proto: "start_date"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._modificationsID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._affectedTripID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._startDate) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripDescriptor.ModifiedTripSelector.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modificationsID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._affectedTripID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startDate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripDescriptor.ModifiedTripSelector, rhs: TransitRealtime_TripDescriptor.ModifiedTripSelector) -> Bool {
    if lhs._modificationsID != rhs._modificationsID {return false}
    if lhs._affectedTripID != rhs._affectedTripID {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._startDate != rhs._startDate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_VehicleDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VehicleDescriptor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "label"),
    3: .standard(proto: "license_plate"),
    4: .standard(proto: "wheelchair_accessible"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._licensePlate) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._wheelchairAccessible) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_VehicleDescriptor.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._label {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._licensePlate {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._wheelchairAccessible {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_VehicleDescriptor, rhs: TransitRealtime_VehicleDescriptor) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._label != rhs._label {return false}
    if lhs._licensePlate != rhs._licensePlate {return false}
    if lhs._wheelchairAccessible != rhs._wheelchairAccessible {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_VehicleDescriptor.WheelchairAccessible: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_VALUE"),
    1: .same(proto: "UNKNOWN"),
    2: .same(proto: "WHEELCHAIR_ACCESSIBLE"),
    3: .same(proto: "WHEELCHAIR_INACCESSIBLE"),
  ]
}

extension TransitRealtime_EntitySelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EntitySelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "agency_id"),
    2: .standard(proto: "route_id"),
    3: .standard(proto: "route_type"),
    4: .same(proto: "trip"),
    5: .standard(proto: "stop_id"),
    6: .standard(proto: "direction_id"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._trip, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._agencyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._routeID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._routeType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._trip) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._directionID) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_EntitySelector.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._agencyID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._routeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._routeType {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._trip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._directionID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_EntitySelector, rhs: TransitRealtime_EntitySelector) -> Bool {
    if lhs._agencyID != rhs._agencyID {return false}
    if lhs._routeID != rhs._routeID {return false}
    if lhs._routeType != rhs._routeType {return false}
    if lhs._trip != rhs._trip {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs._directionID != rhs._directionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedString: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranslatedString"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "translation"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.translation) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.translation) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedString.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.translation.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.translation, fieldNumber: 1)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TranslatedString, rhs: TransitRealtime_TranslatedString) -> Bool {
    if lhs.translation != rhs.translation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedString.Translation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TranslatedString.protoMessageName + ".Translation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._text == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedString.Translation.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TranslatedString.Translation, rhs: TransitRealtime_TranslatedString.Translation) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TranslatedImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "localized_image"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.localizedImage) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.localizedImage) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedImage.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localizedImage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localizedImage, fieldNumber: 1)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TranslatedImage, rhs: TransitRealtime_TranslatedImage) -> Bool {
    if lhs.localizedImage != rhs.localizedImage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TranslatedImage.LocalizedImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TranslatedImage.protoMessageName + ".LocalizedImage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .standard(proto: "media_type"),
    3: .same(proto: "language"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if self._url == nil {return false}
    if self._mediaType == nil {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._mediaType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._language) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TranslatedImage.LocalizedImage.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mediaType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._language {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TranslatedImage.LocalizedImage, rhs: TransitRealtime_TranslatedImage.LocalizedImage) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._mediaType != rhs._mediaType {return false}
    if lhs._language != rhs._language {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Shape: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Shape"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "shape_id"),
    2: .standard(proto: "encoded_polyline"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._shapeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._encodedPolyline) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Shape.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._shapeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._encodedPolyline {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_Shape, rhs: TransitRealtime_Shape) -> Bool {
    if lhs._shapeID != rhs._shapeID {return false}
    if lhs._encodedPolyline != rhs._encodedPolyline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Stop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_id"),
    2: .standard(proto: "stop_code"),
    3: .standard(proto: "stop_name"),
    4: .standard(proto: "tts_stop_name"),
    5: .standard(proto: "stop_desc"),
    6: .standard(proto: "stop_lat"),
    7: .standard(proto: "stop_lon"),
    8: .standard(proto: "zone_id"),
    9: .standard(proto: "stop_url"),
    11: .standard(proto: "parent_station"),
    12: .standard(proto: "stop_timezone"),
    13: .standard(proto: "wheelchair_boarding"),
    14: .standard(proto: "level_id"),
    15: .standard(proto: "platform_code"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._stopCode, !v.isInitialized {return false}
    if let v = self._stopName, !v.isInitialized {return false}
    if let v = self._ttsStopName, !v.isInitialized {return false}
    if let v = self._stopDesc, !v.isInitialized {return false}
    if let v = self._stopURL, !v.isInitialized {return false}
    if let v = self._platformCode, !v.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stopCode) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stopName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ttsStopName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._stopDesc) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._stopLat) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._stopLon) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._zoneID) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._stopURL) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._parentStation) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._stopTimezone) }()
      case 13: try { try decoder.decodeSingularEnumField(value: &self._wheelchairBoarding) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self._levelID) }()
      case 15: try { try decoder.decodeSingularMessageField(value: &self._platformCode) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_Stop.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._stopName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ttsStopName {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._stopDesc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._stopLat {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._stopLon {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._zoneID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._stopURL {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._parentStation {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._stopTimezone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._wheelchairBoarding {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._levelID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 14)
    } }()
    try { if let v = self._platformCode {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_Stop, rhs: TransitRealtime_Stop) -> Bool {
    if lhs._stopID != rhs._stopID {return false}
    if lhs._stopCode != rhs._stopCode {return false}
    if lhs._stopName != rhs._stopName {return false}
    if lhs._ttsStopName != rhs._ttsStopName {return false}
    if lhs._stopDesc != rhs._stopDesc {return false}
    if lhs._stopLat != rhs._stopLat {return false}
    if lhs._stopLon != rhs._stopLon {return false}
    if lhs._zoneID != rhs._zoneID {return false}
    if lhs._stopURL != rhs._stopURL {return false}
    if lhs._parentStation != rhs._parentStation {return false}
    if lhs._stopTimezone != rhs._stopTimezone {return false}
    if lhs._wheelchairBoarding != rhs._wheelchairBoarding {return false}
    if lhs._levelID != rhs._levelID {return false}
    if lhs._platformCode != rhs._platformCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_Stop.WheelchairBoarding: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "AVAILABLE"),
    2: .same(proto: "NOT_AVAILABLE"),
  ]
}

extension TransitRealtime_TripModifications: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TripModifications"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "selected_trips"),
    2: .standard(proto: "start_times"),
    3: .standard(proto: "service_dates"),
    4: .same(proto: "modifications"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.selectedTrips) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.modifications) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.selectedTrips) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.startTimes) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.serviceDates) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.modifications) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripModifications.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.selectedTrips.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.selectedTrips, fieldNumber: 1)
    }
    if !self.startTimes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.startTimes, fieldNumber: 2)
    }
    if !self.serviceDates.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceDates, fieldNumber: 3)
    }
    if !self.modifications.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modifications, fieldNumber: 4)
    }
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripModifications, rhs: TransitRealtime_TripModifications) -> Bool {
    if lhs.selectedTrips != rhs.selectedTrips {return false}
    if lhs.startTimes != rhs.startTimes {return false}
    if lhs.serviceDates != rhs.serviceDates {return false}
    if lhs.modifications != rhs.modifications {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripModifications.Modification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripModifications.protoMessageName + ".Modification"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_stop_selector"),
    2: .standard(proto: "end_stop_selector"),
    3: .standard(proto: "propagated_modification_delay"),
    4: .standard(proto: "replacement_stops"),
    5: .standard(proto: "service_alert_id"),
    6: .standard(proto: "last_modified_time"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    if let v = self._startStopSelector, !v.isInitialized {return false}
    if let v = self._endStopSelector, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.replacementStops) {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startStopSelector) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endStopSelector) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._propagatedModificationDelay) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.replacementStops) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._serviceAlertID) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._lastModifiedTime) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripModifications.Modification.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startStopSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endStopSelector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._propagatedModificationDelay {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    if !self.replacementStops.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.replacementStops, fieldNumber: 4)
    }
    try { if let v = self._serviceAlertID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._lastModifiedTime {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripModifications.Modification, rhs: TransitRealtime_TripModifications.Modification) -> Bool {
    if lhs._startStopSelector != rhs._startStopSelector {return false}
    if lhs._endStopSelector != rhs._endStopSelector {return false}
    if lhs._propagatedModificationDelay != rhs._propagatedModificationDelay {return false}
    if lhs.replacementStops != rhs.replacementStops {return false}
    if lhs._serviceAlertID != rhs._serviceAlertID {return false}
    if lhs._lastModifiedTime != rhs._lastModifiedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_TripModifications.SelectedTrips: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = TransitRealtime_TripModifications.protoMessageName + ".SelectedTrips"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "trip_ids"),
    2: .standard(proto: "shape_id"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.tripIds) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._shapeID) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_TripModifications.SelectedTrips.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tripIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tripIds, fieldNumber: 1)
    }
    try { if let v = self._shapeID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_TripModifications.SelectedTrips, rhs: TransitRealtime_TripModifications.SelectedTrips) -> Bool {
    if lhs.tripIds != rhs.tripIds {return false}
    if lhs._shapeID != rhs._shapeID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_StopSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopSelector"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stop_sequence"),
    2: .standard(proto: "stop_id"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._stopSequence) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_StopSelector.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stopSequence {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_StopSelector, rhs: TransitRealtime_StopSelector) -> Bool {
    if lhs._stopSequence != rhs._stopSequence {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}

extension TransitRealtime_ReplacementStop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplacementStop"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "travel_time_to_stop"),
    2: .standard(proto: "stop_id"),
  ]

  public var isInitialized: Bool {
    if !_protobuf_extensionFieldValues.isInitialized {return false}
    return true
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._travelTimeToStop) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._stopID) }()
      case 1000..<2000, 9000..<10000:
        try { try decoder.decodeExtensionField(values: &_protobuf_extensionFieldValues, messageType: TransitRealtime_ReplacementStop.self, fieldNumber: fieldNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._travelTimeToStop {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stopID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try visitor.visitExtensionFields(fields: _protobuf_extensionFieldValues, start: 1000, end: 10000)
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: TransitRealtime_ReplacementStop, rhs: TransitRealtime_ReplacementStop) -> Bool {
    if lhs._travelTimeToStop != rhs._travelTimeToStop {return false}
    if lhs._stopID != rhs._stopID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    if lhs._protobuf_extensionFieldValues != rhs._protobuf_extensionFieldValues {return false}
    return true
  }
}
